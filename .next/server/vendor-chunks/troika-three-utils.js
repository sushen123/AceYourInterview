"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/troika-three-utils";
exports.ids = ["vendor-chunks/troika-three-utils"];
exports.modules = {

/***/ "(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierMesh: () => (/* binding */ BezierMesh),\n/* harmony export */   createDerivedMaterial: () => (/* binding */ createDerivedMaterial),\n/* harmony export */   expandShaderIncludes: () => (/* binding */ expandShaderIncludes),\n/* harmony export */   getShaderUniformTypes: () => (/* binding */ getShaderUniformTypes),\n/* harmony export */   getShadersForMaterial: () => (/* binding */ getShadersForMaterial),\n/* harmony export */   invertMatrix4: () => (/* binding */ invertMatrix4),\n/* harmony export */   voidMainRegExp: () => (/* binding */ voidMainRegExp)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\nfunction expandShaderIncludes( source ) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    let chunk = three__WEBPACK_IMPORTED_MODULE_0__.ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match\n  }\n  return source.replace( pattern, replace )\n}\n\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nfunction generateUUID() {\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase()\n\n}\n\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n};\n\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object} options.defines - Custom `defines` for the material\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]()\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  const onBeforeCompile = function (shaderInfo, renderer) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {return Date.now() - epoch}\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\n  };\n\n  const derive = function(base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n    derived.uuid = generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n\n    return derived\n  };\n\n  const descriptor = {\n    constructor: {value: DerivedMaterial},\n    isDerivedMaterial: {value: true},\n\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n      }\n    },\n\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile\n      },\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(source.uniforms));\n        }\n        return this\n      }\n    },\n\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this)\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDepthMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({ depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking }),\n            options\n          );\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDistanceMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDistanceMaterial(),\n            options\n          );\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }\n    },\n\n    dispose: {\n      writable: true,\n      configurable: true,\n      value() {\n        const {_depthMaterial, _distanceMaterial} = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial()\n}\n\n\nfunction upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(\n      /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n    );\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    let res = customRewriter({vertexShader, fragmentShader});\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n      match => {\n        postChunks.push(match);\n        return ''\n      }\n    );\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n    vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n    });\n\n    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n    // Perhaps the other textures too going forward?\n    if (!(material.map && material.map.channel > 0)) {\n      vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n    }\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n  return {\n    vertexShader,\n    fragmentShader\n  }\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n    );\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n  return shaderCode\n}\n\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n  }\n  return id\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n}\n\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms\n}\n\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\nfunction invertMatrix4(srcMatrix, tgtMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()) {\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n  return tgtMatrix\n}\n\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\n\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(\n    baseMaterial,\n    {\n      chained: true,\n      uniforms: {\n        pointA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        pointB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        radius: {value: 0.01},\n        dashing: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()} //on, off, offset\n      },\n      vertexDefs,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro\n    }\n  )\n}\n\nlet geometry = null;\n\nconst defaultBaseMaterial = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({color: 0xffffff, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide});\n\n\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\nclass BezierMesh extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n  static getGeometry() {\n    return geometry || (geometry =\n      new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n    )\n  }\n\n  constructor() {\n    super(\n      BezierMesh.getGeometry(),\n      defaultBaseMaterial\n    );\n\n    this.pointA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.pointB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.radius = 0.01;\n    this.dashArray = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    this.frustumCulled = false;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial\n  }\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial()\n  }\n\n  onBeforeRender() {\n    const {uniforms} = this.material;\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(/*raycaster, intersects*/) {\n    // TODO - just fail for now\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXV0aWxzL2Rpc3QvdHJvaWthLXRocmVlLXV0aWxzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUE4TTs7QUFFOU07QUFDQSxxREFBcUQ7QUFDckQsVUFBVTtBQUNWO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLGtFQUFrRSxrQkFBa0I7QUFDdkcsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNB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QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLG1FQUFtRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXZlbGV2YXRlLy4vbm9kZV9tb2R1bGVzL3Ryb2lrYS10aHJlZS11dGlscy9kaXN0L3Ryb2lrYS10aHJlZS11dGlscy5lc20uanM/MDE5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaGFkZXJDaHVuaywgVW5pZm9ybXNVdGlscywgTWVzaERlcHRoTWF0ZXJpYWwsIFJHQkFEZXB0aFBhY2tpbmcsIE1lc2hEaXN0YW5jZU1hdGVyaWFsLCBTaGFkZXJMaWIsIE1hdHJpeDQsIFZlY3RvcjMsIE1lc2gsIEN5bGluZGVyR2VvbWV0cnksIFZlY3RvcjIsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBEb3VibGVTaWRlIH0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgdGhlIGB2b2lkIG1haW4oKSB7YCBvcGVuZXIgbGluZSBpbiBHTFNMLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3Qgdm9pZE1haW5SZWdFeHAgPSAvXFxidm9pZFxccyttYWluXFxzKlxcKFxccypcXClcXHMqey9nO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4cGFuZHMgYWxsIGAjaW5jbHVkZSA8eHl6PmAgc3RhdGVtZW50cyB3aXRoaW4gc3RyaW5nIG9mIHNoYWRlciBjb2RlLlxuICogQ29waWVkIGZyb20gdGhyZWUncyBXZWJHTFByb2dyYW0jcGFyc2VJbmNsdWRlcyBmb3IgZXh0ZXJuYWwgdXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgLSBUaGUgR0xTTCBzb3VyY2UgY29kZSB0byBldmFsdWF0ZVxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgR0xTTCBjb2RlIHdpdGggYWxsIGluY2x1ZGVzIGV4cGFuZGVkXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZFNoYWRlckluY2x1ZGVzKCBzb3VyY2UgKSB7XG4gIGNvbnN0IHBhdHRlcm4gPSAvXlsgXFx0XSojaW5jbHVkZSArPChbXFx3XFxkLi9dKyk+L2dtO1xuICBmdW5jdGlvbiByZXBsYWNlKG1hdGNoLCBpbmNsdWRlKSB7XG4gICAgbGV0IGNodW5rID0gU2hhZGVyQ2h1bmtbaW5jbHVkZV07XG4gICAgcmV0dXJuIGNodW5rID8gZXhwYW5kU2hhZGVySW5jbHVkZXMoY2h1bmspIDogbWF0Y2hcbiAgfVxuICByZXR1cm4gc291cmNlLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKVxufVxuXG4vKlxuICogVGhpcyBpcyBhIGRpcmVjdCBjb3B5IG9mIE1hdGhVdGlscy5nZW5lcmF0ZVVVSUQgZnJvbSBUaHJlZS5qcywgdG8gcHJlc2VydmUgY29tcGF0aWJpbGl0eSB3aXRoIHRocmVlXG4gKiB2ZXJzaW9ucyBiZWZvcmUgMC4xMTMuMCBhcyBpdCB3YXMgY2hhbmdlZCBmcm9tIE1hdGggdG8gTWF0aFV0aWxzIGluIHRoYXQgdmVyc2lvbi5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvYmxvYi9kZDhiNWFhM2IyNzBjMTcwOTZiOTA5NDVjZDJkNmQxYjEzYWFlYzUzL3NyYy9tYXRoL01hdGhVdGlscy5qcyNMMTZcbiAqL1xuXG5jb25zdCBfbHV0ID0gW107XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgX2x1dFtpXSA9IChpIDwgMTYgPyAnMCcgOiAnJykgKyAoaSkudG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG5cbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XG5cbiAgY29uc3QgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IHV1aWQgPSBfbHV0W2QwICYgMHhmZl0gKyBfbHV0W2QwID4+IDggJiAweGZmXSArIF9sdXRbZDAgPj4gMTYgJiAweGZmXSArIF9sdXRbZDAgPj4gMjQgJiAweGZmXSArICctJyArXG4gICAgX2x1dFtkMSAmIDB4ZmZdICsgX2x1dFtkMSA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QxID4+IDE2ICYgMHgwZiB8IDB4NDBdICsgX2x1dFtkMSA+PiAyNCAmIDB4ZmZdICsgJy0nICtcbiAgICBfbHV0W2QyICYgMHgzZiB8IDB4ODBdICsgX2x1dFtkMiA+PiA4ICYgMHhmZl0gKyAnLScgKyBfbHV0W2QyID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QyID4+IDI0ICYgMHhmZl0gK1xuICAgIF9sdXRbZDMgJiAweGZmXSArIF9sdXRbZDMgPj4gOCAmIDB4ZmZdICsgX2x1dFtkMyA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMyA+PiAyNCAmIDB4ZmZdO1xuXG4gIC8vIC50b1VwcGVyQ2FzZSgpIGhlcmUgZmxhdHRlbnMgY29uY2F0ZW5hdGVkIHN0cmluZ3MgdG8gc2F2ZSBoZWFwIG1lbW9yeSBzcGFjZS5cbiAgcmV0dXJuIHV1aWQudG9VcHBlckNhc2UoKVxuXG59XG5cbi8vIExvY2FsIGFzc2lnbiBwb2x5ZmlsbCB0byBhdm9pZCBpbXBvcnRpbmcgdHJvaWthLWNvcmVcbmNvbnN0IGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24oLyp0YXJnZXQsIC4uLnNvdXJjZXMqLykge1xuICBsZXQgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuICBmb3IgKGxldCBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufTtcblxuXG5jb25zdCBlcG9jaCA9IERhdGUubm93KCk7XG5jb25zdCBDT05TVFJVQ1RPUl9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBTSEFERVJfVVBHUkFERV9DQUNIRSA9IG5ldyBNYXAoKTtcblxuLy8gTWF0ZXJpYWwgaWRzIG11c3QgYmUgaW50ZWdlcnMsIGJ1dCB3ZSBjYW4ndCBhY2Nlc3MgdGhlIGluY3JlbWVudCBmcm9tIFRocmVlJ3MgYE1hdGVyaWFsYCBtb2R1bGUsXG4vLyBzbyBsZXQncyBjaG9vc2UgYSBzdWZmaWNpZW50bHkgbGFyZ2Ugc3RhcnRpbmcgdmFsdWUgdGhhdCBzaG91bGQgdGhlb3JldGljYWxseSBuZXZlciBjb2xsaWRlLlxubGV0IG1hdGVyaWFsSW5zdGFuY2VJZCA9IDFlMTA7XG5cbi8qKlxuICogQSB1dGlsaXR5IGZvciBjcmVhdGluZyBhIGN1c3RvbSBzaGFkZXIgbWF0ZXJpYWwgZGVyaXZlZCBmcm9tIGFub3RoZXIgbWF0ZXJpYWwnc1xuICogc2hhZGVycy4gVGhpcyBhbGxvd3MgeW91IHRvIGluamVjdCBjdXN0b20gc2hhZGVyIGxvZ2ljIGFuZCB0cmFuc2Zvcm1zIGludG8gdGhlXG4gKiBidWlsdGluIFRocmVlSlMgbWF0ZXJpYWxzIHdpdGhvdXQgaGF2aW5nIHRvIHJlY3JlYXRlIHRoZW0gZnJvbSBzY3JhdGNoLlxuICpcbiAqIEBwYXJhbSB7VEhSRUUuTWF0ZXJpYWx9IGJhc2VNYXRlcmlhbCAtIHRoZSBvcmlnaW5hbCBtYXRlcmlhbCB0byBkZXJpdmUgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gSG93IHRoZSBiYXNlIG1hdGVyaWFsIHNob3VsZCBiZSBtb2RpZmllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRlZmluZXMgLSBDdXN0b20gYGRlZmluZXNgIGZvciB0aGUgbWF0ZXJpYWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmV4dGVuc2lvbnMgLSBDdXN0b20gYGV4dGVuc2lvbnNgIGZvciB0aGUgbWF0ZXJpYWwsIGUuZy4gYHtkZXJpdmF0aXZlczogdHJ1ZX1gXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy51bmlmb3JtcyAtIEN1c3RvbSBgdW5pZm9ybXNgIGZvciB1c2UgaW4gdGhlIG1vZGlmaWVkIHNoYWRlci4gVGhlc2UgY2FuXG4gKiAgICAgICAgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkIHZpYSB0aGUgcmVzdWx0aW5nIG1hdGVyaWFsJ3MgYHVuaWZvcm1zYCBwcm9wZXJ0eSwganVzdCBsaWtlXG4gKiAgICAgICAgaW4gYSBTaGFkZXJNYXRlcmlhbC4gWW91IGRvIG5vdCBuZWVkIHRvIHJlcGVhdCB0aGUgYmFzZSBtYXRlcmlhbCdzIG93biB1bmlmb3JtcyBoZXJlLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltZVVuaWZvcm0gLSBJZiBzcGVjaWZpZWQsIGEgdW5pZm9ybSBvZiB0aGlzIG5hbWUgd2lsbCBiZSBpbmplY3RlZCBpbnRvXG4gKiAgICAgICAgYm90aCBzaGFkZXJzLCBhbmQgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHVwZGF0ZWQgb24gZWFjaCByZW5kZXIgZnJhbWUgd2l0aCBhIG51bWJlciBvZlxuICogICAgICAgIGVsYXBzZWQgbWlsbGlzZWNvbmRzLiBUaGUgXCJ6ZXJvXCIgZXBvY2ggdGltZSBpcyBub3Qgc2lnbmlmaWNhbnQgc28gZG9uJ3QgcmVseSBvbiB0aGlzIGFzIGFcbiAqICAgICAgICB0cnVlIGNhbGVuZGFyIHRpbWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhEZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgdmVydGV4IHNoYWRlcidzIHRvcC1sZXZlbFxuICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnZlcnRleE1haW5JbnRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSB0b3Agb2YgdGhlIHZlcnRleFxuICogICAgICAgIHNoYWRlcidzIGB2b2lkIG1haW5gIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudmVydGV4TWFpbk91dHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIGVuZCBvZiB0aGUgdmVydGV4XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy52ZXJ0ZXhUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBwb3NpdGlvbmAsIGBub3JtYWxgLFxuICogICAgICAgIGFuZC9vciBgdXZgIHZlcnRleCBhdHRyaWJ1dGVzLiBUaGlzIGNvZGUgd2lsbCBiZSB3cmFwcGVkIHdpdGhpbiBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gd2l0aFxuICogICAgICAgIHRob3NlIGF0dHJpYnV0ZXMgZXhwb3NlZCBieSB0aGVpciBub3JtYWwgbmFtZXMgYXMgcmVhZC93cml0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudERlZnMgLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBpbnRvIHRoZSBmcmFnbWVudCBzaGFkZXIncyB0b3AtbGV2ZWxcbiAqICAgICAgICBkZWZpbml0aW9ucywgYWJvdmUgdGhlIGB2b2lkIG1haW4oKWAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudE1haW5JbnRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSB0b3Agb2YgdGhlIGZyYWdtZW50XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5mcmFnbWVudE1haW5PdXRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uIFlvdSBjYW4gbWFuaXB1bGF0ZSBgZ2xfRnJhZ0NvbG9yYCBoZXJlIGJ1dCBrZWVwIGluIG1pbmQgaXQgZ29lc1xuICogICAgICAgIGFmdGVyIGFueSBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIHNvIGlmIHlvdVxuICogICAgICAgIHdhbnQgdGhvc2UgdG8gYXBwbHkgdG8geW91ciBjaGFuZ2VzIHVzZSBgZnJhZ21lbnRDb2xvclRyYW5zZm9ybWAgaW5zdGVhZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBnbF9GcmFnQ29sb3JgXG4gKiAgICAgICAgb3V0cHV0IHZhbHVlLiBXaWxsIGJlIGluamVjdGVkIG5lYXIgdGhlIGVuZCBvZiB0aGUgYHZvaWQgbWFpbmAgZnVuY3Rpb24sIGJ1dCBiZWZvcmUgYW55XG4gKiAgICAgICAgb2YgVGhyZWVKUydzIGNvbG9yIHBvc3Rwcm9jZXNzaW5nIHNoYWRlciBjaHVua3MgKHRvbmVtYXBwaW5nLCBmb2csIGV0Yy4pLCBhbmQgYmVmb3JlIHRoZVxuICogICAgICAgIGBmcmFnbWVudE1haW5PdXRyb2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uPHt2ZXJ0ZXhTaGFkZXIsZnJhZ21lbnRTaGFkZXJ9Pjp7dmVydGV4U2hhZGVyLGZyYWdtZW50U2hhZGVyfX0gb3B0aW9ucy5jdXN0b21SZXdyaXRlciAtIEEgZnVuY3Rpb25cbiAqICAgICAgICBmb3IgcGVyZm9ybWluZyBjdXN0b20gcmV3cml0ZXMgb2YgdGhlIGZ1bGwgc2hhZGVyIGNvZGUuIFVzZWZ1bCBpZiB5b3UgbmVlZCB0byBkbyBzb21ldGhpbmdcbiAqICAgICAgICBzcGVjaWFsIHRoYXQncyBub3QgY292ZXJlZCBieSB0aGUgb3RoZXIgYnVpbHRpbiBvcHRpb25zLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlXG4gKiAgICAgICAgYW55IG90aGVyIHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY2hhaW5lZCAtIFNldCB0byBgdHJ1ZWAgdG8gcHJvdG90eXBlLWNoYWluIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIHRoZSBiYXNlXG4gKiAgICAgICAgbWF0ZXJpYWwsIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGNvcHlpbmcgaXQuIFRoaXMgYWxsb3dzIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvXG4gKiAgICAgICAgYXV0b21hdGljYWxseSBwaWNrIHVwIGNoYW5nZXMgbWFkZSB0byB0aGUgYmFzZSBtYXRlcmlhbCBhbmQgaXRzIHByb3BlcnRpZXMuIFRoaXMgY2FuIGJlIHVzZWZ1bFxuICogICAgICAgIHdoZXJlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGlzIGhpZGRlbiBmcm9tIHRoZSB1c2VyIGFzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCwgYWxsb3dpbmcgdGhlbVxuICogICAgICAgIHRvIHdvcmsgd2l0aCB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgbGlrZSBub3JtYWwuIEJ1dCBpdCBjYW4gcmVzdWx0IGluIHVuZXhwZWN0ZWQgYmVoYXZpb3IgaWYgbm90XG4gKiAgICAgICAgaGFuZGxlZCBjYXJlZnVsbHkuXG4gKlxuICogQHJldHVybiB7VEhSRUUuTWF0ZXJpYWx9XG4gKlxuICogVGhlIHJldHVybmVkIG1hdGVyaWFsIHdpbGwgYWxzbyBoYXZlIHR3byBuZXcgbWV0aG9kcywgYGdldERlcHRoTWF0ZXJpYWwoKWAgYW5kIGBnZXREaXN0YW5jZU1hdGVyaWFsKClgLFxuICogd2hpY2ggY2FuIGJlIGNhbGxlZCB0byBnZXQgYSB2YXJpYW50IG9mIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGZvciB1c2UgaW4gc2hhZG93IGNhc3RpbmcuIElmIHRoZVxuICogdGFyZ2V0IG1lc2ggaXMgZXhwZWN0ZWQgdG8gY2FzdCBzaGFkb3dzLCB0aGVuIHlvdSBjYW4gYXNzaWduIHRoZXNlIHRvIHRoZSBtZXNoJ3MgYGN1c3RvbURlcHRoTWF0ZXJpYWxgXG4gKiAoZm9yIGRpcmVjdGlvbmFsIGFuZCBzcG90IGxpZ2h0cykgYW5kL29yIGBjdXN0b21EaXN0YW5jZU1hdGVyaWFsYCAoZm9yIHBvaW50IGxpZ2h0cykgcHJvcGVydGllcyB0b1xuICogYWxsb3cgdGhlIGNhc3Qgc2hhZG93IHRvIGhvbm9yIHlvdXIgZGVyaXZlZCBzaGFkZXIncyB2ZXJ0ZXggdHJhbnNmb3JtcyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy4gVGhlc2VcbiAqIHdpbGwgYWxzbyBzZXQgYSBjdXN0b20gYCNkZWZpbmUgSVNfREVQVEhfTUFURVJJQUxgIG9yIGAjZGVmaW5lIElTX0RJU1RBTkNFX01BVEVSSUFMYCB0aGF0IHlvdSBjYW4gbG9va1xuICogZm9yIGluIHlvdXIgZGVyaXZlZCBzaGFkZXJzIHdpdGggYCNpZmRlZmAgdG8gY3VzdG9taXplIHRoZWlyIGJlaGF2aW9yIGZvciB0aGUgZGVwdGggb3IgZGlzdGFuY2VcbiAqIHNjZW5hcmlvcywgZS5nLiBza2lwcGluZyBhbnRpYWxpYXNpbmcgb3IgZXhwZW5zaXZlIHNoYWRlciBsb2dpYy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwgb3B0aW9ucykge1xuICAvLyBHZW5lcmF0ZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgY29udGVudCBvZiB0aGVzZSBgb3B0aW9uc2AuIFdlJ2xsIHVzZSB0aGlzXG4gIC8vIHRocm91Z2hvdXQgZm9yIGNhY2hpbmcgYW5kIGZvciBnZW5lcmF0aW5nIHRoZSB1cGdyYWRlZCBzaGFkZXIgY29kZS4gVGhpcyBpbmNyZWFzZXNcbiAgLy8gdGhlIGxpa2VsaWhvb2QgdGhhdCB0aGUgcmVzdWx0aW5nIHNoYWRlcnMgd2lsbCBsaW5lIHVwIGFjcm9zcyBtdWx0aXBsZSBjYWxscyBzb1xuICAvLyB0aGVpciBHTCBwcm9ncmFtcyBjYW4gYmUgc2hhcmVkIGFuZCBjYWNoZWQuXG4gIGNvbnN0IG9wdGlvbnNLZXkgPSBnZXRLZXlGb3JPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IGRlcml2ZWQgZnJvbSB0aGlzIGJhc2VNYXRlcmlhbCB1c2luZyB0aGlzXG4gIC8vIHVuaXF1ZSBzZXQgb2Ygb3B0aW9ucywgYW5kIGlmIHNvIHJldXNlIHRoZSBjb25zdHJ1Y3RvciB0byBhdm9pZCBzb21lIGFsbG9jYXRpb25zLlxuICBsZXQgY3RvcnNCeURlcml2YXRpb24gPSBDT05TVFJVQ1RPUl9DQUNIRS5nZXQoYmFzZU1hdGVyaWFsKTtcbiAgaWYgKCFjdG9yc0J5RGVyaXZhdGlvbikge1xuICAgIENPTlNUUlVDVE9SX0NBQ0hFLnNldChiYXNlTWF0ZXJpYWwsIChjdG9yc0J5RGVyaXZhdGlvbiA9IE9iamVjdC5jcmVhdGUobnVsbCkpKTtcbiAgfVxuICBpZiAoY3RvcnNCeURlcml2YXRpb25bb3B0aW9uc0tleV0pIHtcbiAgICByZXR1cm4gbmV3IGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldKClcbiAgfVxuXG4gIGNvbnN0IHByaXZhdGVCZWZvcmVDb21waWxlUHJvcCA9IGBfb25CZWZvcmVDb21waWxlJHtvcHRpb25zS2V5fWA7XG5cbiAgLy8gUHJpdmF0ZSBvbkJlZm9yZUNvbXBpbGUgaGFuZGxlciB0aGF0IGluamVjdHMgdGhlIG1vZGlmaWVkIHNoYWRlcnMgYW5kIHVuaWZvcm1zIHdoZW5cbiAgLy8gdGhlIHJlbmRlcmVyIHN3aXRjaGVzIHRvIHRoaXMgbWF0ZXJpYWwncyBwcm9ncmFtXG4gIGNvbnN0IG9uQmVmb3JlQ29tcGlsZSA9IGZ1bmN0aW9uIChzaGFkZXJJbmZvLCByZW5kZXJlcikge1xuICAgIGJhc2VNYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUuY2FsbCh0aGlzLCBzaGFkZXJJbmZvLCByZW5kZXJlcik7XG5cbiAgICAvLyBVcGdyYWRlIHRoZSBzaGFkZXJzLCBjYWNoaW5nIHRoZSByZXN1bHQgYnkgaW5jb21pbmcgc291cmNlIGNvZGVcbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuY3VzdG9tUHJvZ3JhbUNhY2hlS2V5KCkgKyAnfCcgKyBzaGFkZXJJbmZvLnZlcnRleFNoYWRlciArICd8JyArIHNoYWRlckluZm8uZnJhZ21lbnRTaGFkZXI7XG4gICAgbGV0IHVwZ3JhZGVkU2hhZGVycyA9IFNIQURFUl9VUEdSQURFX0NBQ0hFW2NhY2hlS2V5XTtcbiAgICBpZiAoIXVwZ3JhZGVkU2hhZGVycykge1xuICAgICAgY29uc3QgdXBncmFkZWQgPSB1cGdyYWRlU2hhZGVycyh0aGlzLCBzaGFkZXJJbmZvLCBvcHRpb25zLCBvcHRpb25zS2V5KTtcbiAgICAgIHVwZ3JhZGVkU2hhZGVycyA9IFNIQURFUl9VUEdSQURFX0NBQ0hFW2NhY2hlS2V5XSA9IHVwZ3JhZGVkO1xuICAgIH1cblxuICAgIC8vIEluamVjdCB1cGdyYWRlZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyBpbnRvIHRoZSBwcm9ncmFtXG4gICAgc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgPSB1cGdyYWRlZFNoYWRlcnMudmVydGV4U2hhZGVyO1xuICAgIHNoYWRlckluZm8uZnJhZ21lbnRTaGFkZXIgPSB1cGdyYWRlZFNoYWRlcnMuZnJhZ21lbnRTaGFkZXI7XG4gICAgYXNzaWduKHNoYWRlckluZm8udW5pZm9ybXMsIHRoaXMudW5pZm9ybXMpO1xuXG4gICAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICAgIGlmIChvcHRpb25zLnRpbWVVbmlmb3JtKSB7XG4gICAgICBzaGFkZXJJbmZvLnVuaWZvcm1zW29wdGlvbnMudGltZVVuaWZvcm1dID0ge1xuICAgICAgICBnZXQgdmFsdWUoKSB7cmV0dXJuIERhdGUubm93KCkgLSBlcG9jaH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVXNlcnMgY2FuIHN0aWxsIGFkZCB0aGVpciBvd24gaGFuZGxlcnMgb24gdG9wIG9mIG91cnNcbiAgICBpZiAodGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKSB7XG4gICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0oc2hhZGVySW5mbyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IERlcml2ZWRNYXRlcmlhbCA9IGZ1bmN0aW9uIERlcml2ZWRNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gZGVyaXZlKG9wdGlvbnMuY2hhaW5lZCA/IGJhc2VNYXRlcmlhbCA6IGJhc2VNYXRlcmlhbC5jbG9uZSgpKVxuICB9O1xuXG4gIGNvbnN0IGRlcml2ZSA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAvLyBQcm90b3R5cGUgY2hhaW4gdG8gdGhlIGJhc2UgbWF0ZXJpYWxcbiAgICBjb25zdCBkZXJpdmVkID0gT2JqZWN0LmNyZWF0ZShiYXNlLCBkZXNjcmlwdG9yKTtcblxuICAgIC8vIFN0b3JlIHRoZSBiYXNlTWF0ZXJpYWwgZm9yIHJlZmVyZW5jZTsgdGhpcyBpcyBhbHdheXMgdGhlIG9yaWdpbmFsIGV2ZW4gd2hlbiBjbG9uaW5nXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWQsICdiYXNlTWF0ZXJpYWwnLCB7IHZhbHVlOiBiYXNlTWF0ZXJpYWwgfSk7XG5cbiAgICAvLyBOZWVkcyBpdHMgb3duIGlkc1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkLCAnaWQnLCB7IHZhbHVlOiBtYXRlcmlhbEluc3RhbmNlSWQrKyB9KTtcbiAgICBkZXJpdmVkLnV1aWQgPSBnZW5lcmF0ZVVVSUQoKTtcblxuICAgIC8vIE1lcmdlIHVuaWZvcm1zLCBkZWZpbmVzLCBhbmQgZXh0ZW5zaW9uc1xuICAgIGRlcml2ZWQudW5pZm9ybXMgPSBhc3NpZ24oe30sIGJhc2UudW5pZm9ybXMsIG9wdGlvbnMudW5pZm9ybXMpO1xuICAgIGRlcml2ZWQuZGVmaW5lcyA9IGFzc2lnbih7fSwgYmFzZS5kZWZpbmVzLCBvcHRpb25zLmRlZmluZXMpO1xuICAgIGRlcml2ZWQuZGVmaW5lc1tgVFJPSUtBX0RFUklWRURfTUFURVJJQUxfJHtvcHRpb25zS2V5fWBdID0gJyc7IC8vZm9yY2UgYSBwcm9ncmFtIGNoYW5nZSBmcm9tIHRoZSBiYXNlIG1hdGVyaWFsXG4gICAgZGVyaXZlZC5leHRlbnNpb25zID0gYXNzaWduKHt9LCBiYXNlLmV4dGVuc2lvbnMsIG9wdGlvbnMuZXh0ZW5zaW9ucyk7XG5cbiAgICAvLyBEb24ndCBpbmhlcml0IEV2ZW50RGlzcGF0Y2hlciBsaXN0ZW5lcnNcbiAgICBkZXJpdmVkLl9saXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gZGVyaXZlZFxuICB9O1xuXG4gIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgY29uc3RydWN0b3I6IHt2YWx1ZTogRGVyaXZlZE1hdGVyaWFsfSxcbiAgICBpc0Rlcml2ZWRNYXRlcmlhbDoge3ZhbHVlOiB0cnVlfSxcblxuICAgIGN1c3RvbVByb2dyYW1DYWNoZUtleToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmFzZU1hdGVyaWFsLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgb3B0aW9uc0tleVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkJlZm9yZUNvbXBpbGU6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG9uQmVmb3JlQ29tcGlsZVxuICAgICAgfSxcbiAgICAgIHNldChmbikge1xuICAgICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0gPSBmbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwuY29weS5jYWxsKHRoaXMsIHNvdXJjZSk7XG4gICAgICAgIGlmICghYmFzZU1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgIWJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbCkge1xuICAgICAgICAgIGFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHNvdXJjZS5leHRlbnNpb25zKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy5kZWZpbmVzLCBzb3VyY2UuZGVmaW5lcyk7XG4gICAgICAgICAgYXNzaWduKHRoaXMudW5pZm9ybXMsIFVuaWZvcm1zVXRpbHMuY2xvbmUoc291cmNlLnVuaWZvcm1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvbmU6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbmV3QmFzZSA9IG5ldyBiYXNlTWF0ZXJpYWwuY29uc3RydWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIGRlcml2ZShuZXdCYXNlKS5jb3B5KHRoaXMpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERlcHRoTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREZXB0aE1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRlcHRoTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gdGhpcy5fZGVwdGhNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoeyBkZXB0aFBhY2tpbmc6IFJHQkFEZXB0aFBhY2tpbmcgfSksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLmRlZmluZXMuSVNfREVQVEhfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtczsgLy9hdXRvbWF0aWNhbGx5IHJlY2lldmUgc2FtZSB1bmlmb3JtIHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aE1hdGVyaWFsXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERpc3RhbmNlTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREaXN0YW5jZU1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsID0gdGhpcy5fZGlzdGFuY2VNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERpc3RhbmNlTWF0ZXJpYWwoKSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwuZGVmaW5lcy5JU19ESVNUQU5DRV9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlTWF0ZXJpYWxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcG9zZToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZSgpIHtcbiAgICAgICAgY29uc3Qge19kZXB0aE1hdGVyaWFsLCBfZGlzdGFuY2VNYXRlcmlhbH0gPSB0aGlzO1xuICAgICAgICBpZiAoX2RlcHRoTWF0ZXJpYWwpIF9kZXB0aE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKF9kaXN0YW5jZU1hdGVyaWFsKSBfZGlzdGFuY2VNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldID0gRGVyaXZlZE1hdGVyaWFsO1xuICByZXR1cm4gbmV3IERlcml2ZWRNYXRlcmlhbCgpXG59XG5cblxuZnVuY3Rpb24gdXBncmFkZVNoYWRlcnMobWF0ZXJpYWwsIHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSwgb3B0aW9ucywga2V5KSB7XG4gIGxldCB7XG4gICAgdmVydGV4RGVmcyxcbiAgICB2ZXJ0ZXhNYWluSW50cm8sXG4gICAgdmVydGV4TWFpbk91dHJvLFxuICAgIHZlcnRleFRyYW5zZm9ybSxcbiAgICBmcmFnbWVudERlZnMsXG4gICAgZnJhZ21lbnRNYWluSW50cm8sXG4gICAgZnJhZ21lbnRNYWluT3V0cm8sXG4gICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSxcbiAgICBjdXN0b21SZXdyaXRlcixcbiAgICB0aW1lVW5pZm9ybVxuICB9ID0gb3B0aW9ucztcblxuICB2ZXJ0ZXhEZWZzID0gdmVydGV4RGVmcyB8fCAnJztcbiAgdmVydGV4TWFpbkludHJvID0gdmVydGV4TWFpbkludHJvIHx8ICcnO1xuICB2ZXJ0ZXhNYWluT3V0cm8gPSB2ZXJ0ZXhNYWluT3V0cm8gfHwgJyc7XG4gIGZyYWdtZW50RGVmcyA9IGZyYWdtZW50RGVmcyB8fCAnJztcbiAgZnJhZ21lbnRNYWluSW50cm8gPSBmcmFnbWVudE1haW5JbnRybyB8fCAnJztcbiAgZnJhZ21lbnRNYWluT3V0cm8gPSBmcmFnbWVudE1haW5PdXRybyB8fCAnJztcblxuICAvLyBFeHBhbmQgaW5jbHVkZXMgaWYgbmVlZGVkXG4gIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyh2ZXJ0ZXhTaGFkZXIpO1xuICB9XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtIHx8IGN1c3RvbVJld3JpdGVyKSB7XG4gICAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIGZpbmQgcG9zdHByb2Nlc3NpbmcgY2h1bmtzIGFmdGVyIGluY2x1ZGUgZXhwYW5zaW9uIGluIG9yZGVyIHRvXG4gICAgLy8gcHV0IHRoZW0gYWZ0ZXIgdGhlIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sIHNvIG1hcmsgdGhlbSB3aXRoIGNvbW1lbnRzIGZpcnN0LiBFdmVuIGlmXG4gICAgLy8gdGhpcyBwYXJ0aWN1bGFyIGRlcml2YXRpb24gZG9lc24ndCBoYXZlIGEgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgb3RoZXIgZGVyaXZhdGlvbnMgbWF5LFxuICAgIC8vIHNvIHdlIHN0aWxsIG1hcmsgdGhlbS5cbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlsgXFx0XSojaW5jbHVkZSA8KCg/OnRvbmVtYXBwaW5nfGVuY29kaW5nc3xmb2d8cHJlbXVsdGlwbGllZF9hbHBoYXxkaXRoZXJpbmcpX2ZyYWdtZW50KT4vZ20sXG4gICAgICAnXFxuLy8hQkVHSU5fUE9TVF9DSFVOSyAkMVxcbiQmXFxuLy8hRU5EX1BPU1RfQ0hVTktcXG4nXG4gICAgKTtcbiAgICBmcmFnbWVudFNoYWRlciA9IGV4cGFuZFNoYWRlckluY2x1ZGVzKGZyYWdtZW50U2hhZGVyKTtcbiAgfVxuXG4gIC8vIEFwcGx5IGN1c3RvbSByZXdyaXRlciBmdW5jdGlvblxuICBpZiAoY3VzdG9tUmV3cml0ZXIpIHtcbiAgICBsZXQgcmVzID0gY3VzdG9tUmV3cml0ZXIoe3ZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXJ9KTtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSByZXMudmVydGV4U2hhZGVyO1xuICAgIGZyYWdtZW50U2hhZGVyID0gcmVzLmZyYWdtZW50U2hhZGVyO1xuICB9XG5cbiAgLy8gVGhlIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gbmVlZHMgdG8gZ28gYmVmb3JlIGFueSBwb3N0cHJvY2Vzc2luZyBjaHVua3MsIHNvIGV4dHJhY3RcbiAgLy8gdGhvc2UgYW5kIHJlLWluc2VydCB0aGVtIGludG8gdGhlIG91dHJvIGluIHRoZSBjb3JyZWN0IHBsYWNlOlxuICBpZiAoZnJhZ21lbnRDb2xvclRyYW5zZm9ybSkge1xuICAgIGxldCBwb3N0Q2h1bmtzID0gW107XG4gICAgZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlci5yZXBsYWNlKFxuICAgICAgL15cXC9cXC8hQkVHSU5fUE9TVF9DSFVOS1teXSs/XlxcL1xcLyFFTkRfUE9TVF9DSFVOSy9nbSwgLy8gW15dKz8gPSBub24tZ3JlZWR5IG1hdGNoIG9mIGFueSBjaGFycyBpbmNsdWRpbmcgbmV3bGluZXNcbiAgICAgIG1hdGNoID0+IHtcbiAgICAgICAgcG9zdENodW5rcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG4gICAgKTtcbiAgICBmcmFnbWVudE1haW5PdXRybyA9IGAke2ZyYWdtZW50Q29sb3JUcmFuc2Zvcm19XFxuJHtwb3N0Q2h1bmtzLmpvaW4oJ1xcbicpfVxcbiR7ZnJhZ21lbnRNYWluT3V0cm99YDtcbiAgfVxuXG4gIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgaWYgKHRpbWVVbmlmb3JtKSB7XG4gICAgY29uc3QgY29kZSA9IGBcXG51bmlmb3JtIGZsb2F0ICR7dGltZVVuaWZvcm19O1xcbmA7XG4gICAgdmVydGV4RGVmcyA9IGNvZGUgKyB2ZXJ0ZXhEZWZzO1xuICAgIGZyYWdtZW50RGVmcyA9IGNvZGUgKyBmcmFnbWVudERlZnM7XG4gIH1cblxuICAvLyBJbmplY3QgYSBmdW5jdGlvbiBmb3IgdGhlIHZlcnRleFRyYW5zZm9ybSBhbmQgcmVuYW1lIGFsbCB1c2FnZXMgb2YgcG9zaXRpb24vbm9ybWFsL3V2XG4gIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0pIHtcbiAgICAvLyBIb2lzdCB0aGVzZSBkZWZzIHRvIHRoZSB2ZXJ5IHRvcCBzbyB0aGV5IHdvcmsgaW4gb3RoZXIgZnVuY3Rpb24gZGVmc1xuICAgIHZlcnRleFNoYWRlciA9IGB2ZWMzIHRyb2lrYV9wb3NpdGlvbl8ke2tleX07XG52ZWMzIHRyb2lrYV9ub3JtYWxfJHtrZXl9O1xudmVjMiB0cm9pa2FfdXZfJHtrZXl9O1xuJHt2ZXJ0ZXhTaGFkZXJ9XG5gO1xuICAgIHZlcnRleERlZnMgPSBgJHt2ZXJ0ZXhEZWZzfVxudm9pZCB0cm9pa2FWZXJ0ZXhUcmFuc2Zvcm0ke2tleX0oaW5vdXQgdmVjMyBwb3NpdGlvbiwgaW5vdXQgdmVjMyBub3JtYWwsIGlub3V0IHZlYzIgdXYpIHtcbiAgJHt2ZXJ0ZXhUcmFuc2Zvcm19XG59XG5gO1xuICAgIHZlcnRleE1haW5JbnRybyA9IGBcbnRyb2lrYV9wb3NpdGlvbl8ke2tleX0gPSB2ZWMzKHBvc2l0aW9uKTtcbnRyb2lrYV9ub3JtYWxfJHtrZXl9ID0gdmVjMyhub3JtYWwpO1xudHJvaWthX3V2XyR7a2V5fSA9IHZlYzIodXYpO1xudHJvaWthVmVydGV4VHJhbnNmb3JtJHtrZXl9KHRyb2lrYV9wb3NpdGlvbl8ke2tleX0sIHRyb2lrYV9ub3JtYWxfJHtrZXl9LCB0cm9pa2FfdXZfJHtrZXl9KTtcbiR7dmVydGV4TWFpbkludHJvfVxuYDtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiKHBvc2l0aW9ufG5vcm1hbHx1dilcXGIvZywgKG1hdGNoLCBtYXRjaDEsIGluZGV4LCBmdWxsU3RyKSA9PiB7XG4gICAgICByZXR1cm4gL1xcYmF0dHJpYnV0ZVxccyt2ZWNbMjNdXFxzKyQvLnRlc3QoZnVsbFN0ci5zdWJzdHIoMCwgaW5kZXgpKSA/IG1hdGNoMSA6IGB0cm9pa2FfJHttYXRjaDF9XyR7a2V5fWBcbiAgICB9KTtcblxuICAgIC8vIFRocmVlIHIxNTIgaW50cm9kdWNlZCB0aGUgTUFQX1VWIHRva2VuLCByZXBsYWNlIGl0IHRvbyBpZiBpdCdzIHBvaW50aW5nIHRvIHRoZSBtYWluICd1didcbiAgICAvLyBQZXJoYXBzIHRoZSBvdGhlciB0ZXh0dXJlcyB0b28gZ29pbmcgZm9yd2FyZD9cbiAgICBpZiAoIShtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmNoYW5uZWwgPiAwKSkge1xuICAgICAgdmVydGV4U2hhZGVyID0gdmVydGV4U2hhZGVyLnJlcGxhY2UoL1xcYk1BUF9VVlxcYi9nLCBgdHJvaWthX3V2XyR7a2V5fWApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEluamVjdCBkZWZzIGFuZCBpbnRyby9vdXRybyBzbmlwcGV0c1xuICB2ZXJ0ZXhTaGFkZXIgPSBpbmplY3RJbnRvU2hhZGVyQ29kZSh2ZXJ0ZXhTaGFkZXIsIGtleSwgdmVydGV4RGVmcywgdmVydGV4TWFpbkludHJvLCB2ZXJ0ZXhNYWluT3V0cm8pO1xuICBmcmFnbWVudFNoYWRlciA9IGluamVjdEludG9TaGFkZXJDb2RlKGZyYWdtZW50U2hhZGVyLCBrZXksIGZyYWdtZW50RGVmcywgZnJhZ21lbnRNYWluSW50cm8sIGZyYWdtZW50TWFpbk91dHJvKTtcblxuICByZXR1cm4ge1xuICAgIHZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlclxuICB9XG59XG5cbmZ1bmN0aW9uIGluamVjdEludG9TaGFkZXJDb2RlKHNoYWRlckNvZGUsIGlkLCBkZWZzLCBpbnRybywgb3V0cm8pIHtcbiAgaWYgKGludHJvIHx8IG91dHJvIHx8IGRlZnMpIHtcbiAgICBzaGFkZXJDb2RlID0gc2hhZGVyQ29kZS5yZXBsYWNlKHZvaWRNYWluUmVnRXhwLCBgXG4ke2RlZnN9XG52b2lkIHRyb2lrYU9yaWdNYWluJHtpZH0oKSB7YFxuICAgICk7XG4gICAgc2hhZGVyQ29kZSArPSBgXG52b2lkIG1haW4oKSB7XG4gICR7aW50cm99XG4gIHRyb2lrYU9yaWdNYWluJHtpZH0oKTtcbiAgJHtvdXRyb31cbn1gO1xuICB9XG4gIHJldHVybiBzaGFkZXJDb2RlXG59XG5cblxuZnVuY3Rpb24gb3B0aW9uc0pzb25SZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gIHJldHVybiBrZXkgPT09ICd1bmlmb3JtcycgPyB1bmRlZmluZWQgOiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWVcbn1cblxubGV0IF9pZEN0ciA9IDA7XG5jb25zdCBvcHRpb25zSGFzaGVzVG9JZHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRLZXlGb3JPcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9uc0hhc2ggPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLCBvcHRpb25zSnNvblJlcGxhY2VyKTtcbiAgbGV0IGlkID0gb3B0aW9uc0hhc2hlc1RvSWRzLmdldChvcHRpb25zSGFzaCk7XG4gIGlmIChpZCA9PSBudWxsKSB7XG4gICAgb3B0aW9uc0hhc2hlc1RvSWRzLnNldChvcHRpb25zSGFzaCwgKGlkID0gKytfaWRDdHIpKTtcbiAgfVxuICByZXR1cm4gaWRcbn1cblxuLy8gQ29waWVkIGZyb20gdGhyZWVqcyBXZWJHTFByb2dyYW1zLmpzIHNvIHdlIGNhbiByZXNvbHZlIGJ1aWx0aW4gbWF0ZXJpYWxzIHRvIHRoZWlyIHNoYWRlcnNcbi8vIFRPRE8gaG93IGNhbiB3ZSBrZWVwIHRoaXMgZnJvbSBnZXR0aW5nIHN0YWxlP1xuY29uc3QgTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSUyA9IHtcbiAgTWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXG4gIE1lc2hEaXN0YW5jZU1hdGVyaWFsOiAnZGlzdGFuY2VSR0JBJyxcbiAgTWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcbiAgTWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gIE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcbiAgTWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG4gIE1lc2hUb29uTWF0ZXJpYWw6ICd0b29uJyxcbiAgTWVzaFN0YW5kYXJkTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gIE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuICBNZXNoTWF0Y2FwTWF0ZXJpYWw6ICdtYXRjYXAnLFxuICBMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgTGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcbiAgUG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnLFxuICBTaGFkb3dNYXRlcmlhbDogJ3NoYWRvdycsXG4gIFNwcml0ZU1hdGVyaWFsOiAnc3ByaXRlJ1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIFRocmVlLmpzIGBNYXRlcmlhbGAgaW5zdGFuY2UsIGZpbmQgdGhlIHNoYWRlcnMvdW5pZm9ybXMgdGhhdCB3aWxsIGJlXG4gKiB1c2VkIHRvIHJlbmRlciB0aGF0IG1hdGVyaWFsLlxuICpcbiAqIEBwYXJhbSBtYXRlcmlhbCAtIHRoZSBNYXRlcmlhbCBpbnN0YW5jZVxuICogQHJldHVybiB7b2JqZWN0fSAtIHRoZSBtYXRlcmlhbCdzIHNoYWRlciBpbmZvOiBge3VuaWZvcm1zOnt9LCBmcmFnbWVudFNoYWRlcjonJywgdmVydGV4U2hhZGVyOicnfWBcbiAqL1xuZnVuY3Rpb24gZ2V0U2hhZGVyc0Zvck1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gIGxldCBidWlsdGluVHlwZSA9IE1BVEVSSUFMX1RZUEVTX1RPX1NIQURFUlNbbWF0ZXJpYWwudHlwZV07XG4gIHJldHVybiBidWlsdGluVHlwZSA/IFNoYWRlckxpYltidWlsdGluVHlwZV0gOiBtYXRlcmlhbCAvL1RPRE8gZmFsbGJhY2sgZm9yIHVua25vd24gdHlwZT9cbn1cblxuLyoqXG4gKiBGaW5kIGFsbCB1bmlmb3JtcyBhbmQgdGhlaXIgdHlwZXMgd2l0aGluIGEgc2hhZGVyIGNvZGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXIgLSBUaGUgc2hhZGVyIGNvZGUgdG8gcGFyc2VcbiAqIEByZXR1cm4ge29iamVjdH0gbWFwcGluZyBvZiB1bmlmb3JtIG5hbWVzIHRvIHRoZWlyIGdsc2wgdHlwZVxuICovXG5mdW5jdGlvbiBnZXRTaGFkZXJVbmlmb3JtVHlwZXMoc2hhZGVyKSB7XG4gIGxldCB1bmlmb3JtUkUgPSAvXFxidW5pZm9ybVxccysoaW50fGZsb2F0fHZlY1syMzRdfG1hdFszNF0pXFxzKyhbQS1aYS16X11bXFx3XSopL2c7XG4gIGxldCB1bmlmb3JtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IHVuaWZvcm1SRS5leGVjKHNoYWRlcikpICE9PSBudWxsKSB7XG4gICAgdW5pZm9ybXNbbWF0Y2hbMl1dID0gbWF0Y2hbMV07XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zXG59XG5cbi8qKlxuICogSGVscGVyIGZvciBzbW9vdGhpbmcgb3V0IHRoZSBgbS5nZXRJbnZlcnNlKHgpYCAtLT4gYG0uY29weSh4KS5pbnZlcnQoKWAgY29udmVyc2lvblxuICogdGhhdCBoYXBwZW5lZCBpbiBUaHJlZUpTIHIxMjMuXG4gKiBAcGFyYW0ge01hdHJpeDR9IHNyY01hdHJpeFxuICogQHBhcmFtIHtNYXRyaXg0fSBbdGd0TWF0cml4XVxuICovXG5mdW5jdGlvbiBpbnZlcnRNYXRyaXg0KHNyY01hdHJpeCwgdGd0TWF0cml4ID0gbmV3IE1hdHJpeDQoKSkge1xuICBpZiAodHlwZW9mIHRndE1hdHJpeC5pbnZlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0Z3RNYXRyaXguY29weShzcmNNYXRyaXgpLmludmVydCgpO1xuICB9IGVsc2Uge1xuICAgIHRndE1hdHJpeC5nZXRJbnZlcnNlKHNyY01hdHJpeCk7XG4gIH1cbiAgcmV0dXJuIHRndE1hdHJpeFxufVxuXG4vKlxuSW5wdXQgZ2VvbWV0cnkgaXMgYSBjeWxpbmRlciB3aXRoIHI9MSwgaGVpZ2h0IGluIHkgZGltZW5zaW9uIGZyb20gMCB0byAxLFxuZGl2aWRlZCBpbnRvIGEgcmVhc29uYWJsZSBudW1iZXIgb2YgaGVpZ2h0IHNlZ21lbnRzLlxuKi9cblxuY29uc3QgdmVydGV4RGVmcyA9IGBcbnVuaWZvcm0gdmVjMyBwb2ludEE7XG51bmlmb3JtIHZlYzMgY29udHJvbEE7XG51bmlmb3JtIHZlYzMgY29udHJvbEI7XG51bmlmb3JtIHZlYzMgcG9pbnRCO1xudW5pZm9ybSBmbG9hdCByYWRpdXM7XG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XG5cbnZlYzMgY3ViaWNCZXppZXIodmVjMyBwMSwgdmVjMyBjMSwgdmVjMyBjMiwgdmVjMyBwMiwgZmxvYXQgdCkge1xuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XG4gIGZsb2F0IGIwID0gdDIgKiB0MiAqIHQyO1xuICBmbG9hdCBiMSA9IDMuMCAqIHQgKiB0MiAqIHQyO1xuICBmbG9hdCBiMiA9IDMuMCAqIHQgKiB0ICogdDI7XG4gIGZsb2F0IGIzID0gdCAqIHQgKiB0O1xuICByZXR1cm4gYjAgKiBwMSArIGIxICogYzEgKyBiMiAqIGMyICsgYjMgKiBwMjtcbn1cblxudmVjMyBjdWJpY0JlemllckRlcml2YXRpdmUodmVjMyBwMSwgdmVjMyBjMSwgdmVjMyBjMiwgdmVjMyBwMiwgZmxvYXQgdCkge1xuICBmbG9hdCB0MiA9IDEuMCAtIHQ7XG4gIHJldHVybiAtMy4wICogcDEgKiB0MiAqIHQyICtcbiAgICBjMSAqICgzLjAgKiB0MiAqIHQyIC0gNi4wICogdDIgKiB0KSArXG4gICAgYzIgKiAoNi4wICogdDIgKiB0IC0gMy4wICogdCAqIHQpICtcbiAgICAzLjAgKiBwMiAqIHQgKiB0O1xufVxuYDtcblxuY29uc3QgdmVydGV4VHJhbnNmb3JtID0gYFxuZmxvYXQgdCA9IHBvc2l0aW9uLnk7XG5iZXppZXJUID0gdDtcbnZlYzMgYmV6aWVyQ2VudGVyUG9zID0gY3ViaWNCZXppZXIocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCk7XG52ZWMzIGJlemllckRpciA9IG5vcm1hbGl6ZShjdWJpY0JlemllckRlcml2YXRpdmUocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCkpO1xuXG4vLyBNYWtlIFwic2lkZXdheXNcIiBhbHdheXMgcGVycGVuZGljdWxhciB0byB0aGUgY2FtZXJhIHJheTsgdGhpcyBlbnN1cmVzIHRoYXQgYW55IHR3aXN0c1xuLy8gaW4gdGhlIGN5bGluZGVyIG9jY3VyIHdoZXJlIHlvdSB3b24ndCBzZWUgdGhlbTogXG52ZWMzIHZpZXdEaXJlY3Rpb24gPSBub3JtYWxNYXRyaXggKiB2ZWMzKDAuMCwgMC4wLCAxLjApO1xuaWYgKGJlemllckRpciA9PSB2aWV3RGlyZWN0aW9uKSB7XG4gIGJlemllckRpciA9IG5vcm1hbGl6ZShjdWJpY0JlemllckRlcml2YXRpdmUocG9pbnRBLCBjb250cm9sQSwgY29udHJvbEIsIHBvaW50QiwgdCA9PSAxLjAgPyB0IC0gMC4wMDAxIDogdCArIDAuMDAwMSkpO1xufVxudmVjMyBzaWRld2F5cyA9IG5vcm1hbGl6ZShjcm9zcyhiZXppZXJEaXIsIHZpZXdEaXJlY3Rpb24pKTtcbnZlYzMgdXBpc2ggPSBub3JtYWxpemUoY3Jvc3Moc2lkZXdheXMsIGJlemllckRpcikpO1xuXG4vLyBCdWlsZCBhIG1hdHJpeCBmb3IgdHJhbnNmb3JtaW5nIHRoaXMgZGlzYyBpbiB0aGUgY3lsaW5kZXI6XG5tYXQ0IGRpc2NUeDtcbmRpc2NUeFswXS54eXogPSBzaWRld2F5cyAqIHJhZGl1cztcbmRpc2NUeFsxXS54eXogPSBiZXppZXJEaXIgKiByYWRpdXM7XG5kaXNjVHhbMl0ueHl6ID0gdXBpc2ggKiByYWRpdXM7XG5kaXNjVHhbM10ueHl6ID0gYmV6aWVyQ2VudGVyUG9zO1xuZGlzY1R4WzNdWzNdID0gMS4wO1xuXG4vLyBBcHBseSB0cmFuc2Zvcm0sIGlnbm9yaW5nIG9yaWdpbmFsIHlcbnBvc2l0aW9uID0gKGRpc2NUeCAqIHZlYzQocG9zaXRpb24ueCwgMC4wLCBwb3NpdGlvbi56LCAxLjApKS54eXo7XG5ub3JtYWwgPSBub3JtYWxpemUobWF0MyhkaXNjVHgpICogbm9ybWFsKTtcbmA7XG5cbmNvbnN0IGZyYWdtZW50RGVmcyA9IGBcbnVuaWZvcm0gdmVjMyBkYXNoaW5nO1xudmFyeWluZyBmbG9hdCBiZXppZXJUO1xuYDtcblxuY29uc3QgZnJhZ21lbnRNYWluSW50cm8gPSBgXG5pZiAoZGFzaGluZy54ICsgZGFzaGluZy55ID4gMC4wKSB7XG4gIGZsb2F0IGRhc2hGcmFjID0gbW9kKGJlemllclQgLSBkYXNoaW5nLnosIGRhc2hpbmcueCArIGRhc2hpbmcueSk7XG4gIGlmIChkYXNoRnJhYyA+IGRhc2hpbmcueCkge1xuICAgIGRpc2NhcmQ7XG4gIH1cbn1cbmA7XG5cbi8vIERlYnVnZ2luZzogc2VwYXJhdGUgY29sb3IgZm9yIGVhY2ggb2YgdGhlIDYgc2lkZXM6XG4vLyBjb25zdCBmcmFnbWVudENvbG9yVHJhbnNmb3JtID0gYFxuLy8gZmxvYXQgc2lkZU51bSA9IGZsb29yKHZVVi54ICogNi4wKTtcbi8vIHZlYzMgbWl4Q29sb3IgPSBzaWRlTnVtIDwgMS4wID8gdmVjMygxLjAsIDAuMCwgMC4wKSA6XG4vLyAgIHNpZGVOdW0gPCAyLjAgPyB2ZWMzKDAuMCwgMS4wLCAxLjApIDpcbi8vICAgc2lkZU51bSA8IDMuMCA/IHZlYzMoMS4wLCAxLjAsIDAuMCkgOlxuLy8gICBzaWRlTnVtIDwgNC4wID8gdmVjMygwLjAsIDAuMCwgMS4wKSA6XG4vLyAgIHNpZGVOdW0gPCA1LjAgPyB2ZWMzKDAuMCwgMS4wLCAwLjApIDpcbi8vICAgdmVjMygxLjAsIDAuMCwgMS4wKTtcbi8vIGdsX0ZyYWdDb2xvci54eXogPSBtaXgoZ2xfRnJhZ0NvbG9yLnh5eiwgbWl4Q29sb3IsIDAuNSk7XG4vLyBgXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gIHJldHVybiBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoXG4gICAgYmFzZU1hdGVyaWFsLFxuICAgIHtcbiAgICAgIGNoYWluZWQ6IHRydWUsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBwb2ludEE6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIGNvbnRyb2xBOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICBjb250cm9sQjoge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgcG9pbnRCOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICByYWRpdXM6IHt2YWx1ZTogMC4wMX0sXG4gICAgICAgIGRhc2hpbmc6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0gLy9vbiwgb2ZmLCBvZmZzZXRcbiAgICAgIH0sXG4gICAgICB2ZXJ0ZXhEZWZzLFxuICAgICAgdmVydGV4VHJhbnNmb3JtLFxuICAgICAgZnJhZ21lbnREZWZzLFxuICAgICAgZnJhZ21lbnRNYWluSW50cm9cbiAgICB9XG4gIClcbn1cblxubGV0IGdlb21ldHJ5ID0gbnVsbDtcblxuY29uc3QgZGVmYXVsdEJhc2VNYXRlcmlhbCA9IC8qI19fUFVSRV9fKi9uZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoe2NvbG9yOiAweGZmZmZmZiwgc2lkZTogRG91YmxlU2lkZX0pO1xuXG5cbi8qKlxuICogQSBUaHJlZUpTIGBNZXNoYCB0aGF0IGJlbmRzIGEgdHViZSBzaGFwZSBhbG9uZyBhIDNEIGN1YmljIGJlemllciBwYXRoLiBUaGUgYmVuZGluZyBpcyBkb25lXG4gKiBieSBkZWZvcm1pbmcgYSBzdHJhaWdodCBjeWxpbmRyaWNhbCBnZW9tZXRyeSBpbiB0aGUgdmVydGV4IHNoYWRlciBiYXNlZCBvbiBhIHNldCBvZiBmb3VyXG4gKiBjb250cm9sIHBvaW50IHVuaWZvcm1zLiBJdCBwYXRjaGVzIHRoZSBuZWNlc3NhcnkgR0xTTCBpbnRvIHRoZSBtZXNoJ3MgYXNzaWduZWQgYG1hdGVyaWFsYFxuICogYXV0b21hdGljYWxseS5cbiAqXG4gKiBUaGUgY3ViaXogYmV6aWVyIHBhdGggaXMgZGV0ZXJtaW5lZCBieSBpdHMgZm91ciBgVmVjdG9yM2AgcHJvcGVydGllczpcbiAqIC0gYHBvaW50QWBcbiAqIC0gYGNvbnRyb2xBYFxuICogLSBgY29udHJvbEJgXG4gKiAtIGBwb2ludEJgXG4gKlxuICogVGhlIHR1YmUncyByYWRpdXMgaXMgY29udHJvbGxlZCBieSBpdHMgYHJhZGl1c2AgcHJvcGVydHksIHdoaWNoIGRlZmF1bHRzIHRvIGAwLjAxYC5cbiAqXG4gKiBZb3UgY2FuIGFsc28gZ2l2ZSB0aGUgdHViZSBhIGRhc2hlZCBhcHBlYXJhbmNlIHdpdGggdHdvIHByb3BlcnRpZXM6XG4gKlxuICogLSBgZGFzaEFycmF5YCAtIGFuIGFycmF5IG9mIHR3byBudW1iZXJzLCBkZWZpbmluZyB0aGUgbGVuZ3RoIG9mIFwib25cIiBhbmQgXCJvZmZcIiBwYXJ0cyBvZlxuICogICB0aGUgZGFzaC4gRWFjaCBpcyBhIDAtMSByYXRpbyBvZiB0aGUgZW50aXJlIHBhdGgncyBsZW5ndGguIChBY3R1YWxseSB0aGlzIGlzIHRoZSBgdGAgbGVuZ3RoXG4gKiAgIHVzZWQgYXMgaW5wdXQgdG8gdGhlIGN1YmljIGJlemllciBmdW5jdGlvbiwgbm90IGl0cyB2aXNpYmxlIGxlbmd0aC4pXG4gKiAtIGBkYXNoT2Zmc2V0YCAtIG9mZnNldCBvZiB3aGVyZSB0aGUgZGFzaCBzdGFydHMuIFlvdSBjYW4gYW5pbWF0ZSB0aGlzIHRvIG1ha2UgdGhlIGRhc2hlcyBtb3ZlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgZGFzaGVzIHdpbGwgYXBwZWFyIGxpa2UgYSBob2xsb3cgdHViZSwgbm90IHNvbGlkLiBUaGlzIHdpbGwgYmUgbW9yZSBhcHBhcmVudCBvblxuICogdGhpY2tlciB0dWJlcy5cbiAqXG4gKiBUT0RPOiBwcm9wZXIgZ2VvbWV0cnkgYm91bmRpbmcgc3BoZXJlIGFuZCByYXljYXN0aW5nXG4gKiBUT0RPOiBhbGxvdyBjb250cm9sIG9mIHRoZSBnZW9tZXRyeSdzIHNlZ21lbnQgY291bnRzXG4gKi9cbmNsYXNzIEJlemllck1lc2ggZXh0ZW5kcyBNZXNoIHtcbiAgc3RhdGljIGdldEdlb21ldHJ5KCkge1xuICAgIHJldHVybiBnZW9tZXRyeSB8fCAoZ2VvbWV0cnkgPVxuICAgICAgbmV3IEN5bGluZGVyR2VvbWV0cnkoMSwgMSwgMSwgNiwgNjQpLnRyYW5zbGF0ZSgwLCAwLjUsIDApXG4gICAgKVxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXG4gICAgICBCZXppZXJNZXNoLmdldEdlb21ldHJ5KCksXG4gICAgICBkZWZhdWx0QmFzZU1hdGVyaWFsXG4gICAgKTtcblxuICAgIHRoaXMucG9pbnRBID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNvbnRyb2xBID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLmNvbnRyb2xCID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLnBvaW50QiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgdGhpcy5yYWRpdXMgPSAwLjAxO1xuICAgIHRoaXMuZGFzaEFycmF5ID0gbmV3IFZlY3RvcjIoKTtcbiAgICB0aGlzLmRhc2hPZmZzZXQgPSAwO1xuXG4gICAgLy8gVE9ETyAtIGRpc2FibGluZyBmcnVzdHVtIGN1bGxpbmcgdW50aWwgSSBmaWd1cmUgb3V0IGhvdyB0byBjdXN0b21pemUgdGhlXG4gICAgLy8gIGdlb21ldHJ5J3MgYm91bmRpbmcgc3BoZXJlIHRoYXQgZ2V0cyB1c2VkXG4gICAgdGhpcy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBIYW5kbGVyIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIHRoZSBiYXNlIG1hdGVyaWFsIHdpdGggb3VyIHVwZ3JhZGVzLiBXZSBkbyB0aGUgd3JhcHBpbmdcbiAgLy8gbGF6aWx5IG9uIF9yZWFkXyByYXRoZXIgdGhhbiB3cml0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3cmFwcGluZyBvbiB0cmFuc2llbnQgdmFsdWVzLlxuICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgbGV0IGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICBjb25zdCBiYXNlTWF0ZXJpYWwgPSB0aGlzLl9iYXNlTWF0ZXJpYWwgfHwgdGhpcy5fZGVmYXVsdE1hdGVyaWFsIHx8ICh0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgPSBkZWZhdWx0QmFzZU1hdGVyaWFsLmNsb25lKCkpO1xuICAgIGlmICghZGVyaXZlZE1hdGVyaWFsIHx8IGRlcml2ZWRNYXRlcmlhbC5iYXNlTWF0ZXJpYWwgIT09IGJhc2VNYXRlcmlhbCkge1xuICAgICAgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsID0gY3JlYXRlQmV6aWVyTWVzaE1hdGVyaWFsKGJhc2VNYXRlcmlhbCk7XG4gICAgICAvLyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHdoZW4gaXRzIGJhc2UgbWF0ZXJpYWwgaXMgZGlzcG9zZWQ6XG4gICAgICBiYXNlTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgYmFzZU1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZXJpdmVkTWF0ZXJpYWxcbiAgfVxuICBzZXQgbWF0ZXJpYWwoYmFzZU1hdGVyaWFsKSB7XG4gICAgdGhpcy5fYmFzZU1hdGVyaWFsID0gYmFzZU1hdGVyaWFsO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuZCB1cGRhdGUgbWF0ZXJpYWwgZm9yIHNoYWRvd3MgdXBvbiByZXF1ZXN0OlxuICBnZXQgY3VzdG9tRGVwdGhNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKClcbiAgfVxuICBnZXQgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgfVxuXG4gIG9uQmVmb3JlUmVuZGVyKCkge1xuICAgIGNvbnN0IHt1bmlmb3Jtc30gPSB0aGlzLm1hdGVyaWFsO1xuICAgIGNvbnN0IHtwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCByYWRpdXMsIGRhc2hBcnJheSwgZGFzaE9mZnNldH0gPSB0aGlzO1xuICAgIHVuaWZvcm1zLnBvaW50QS52YWx1ZS5jb3B5KHBvaW50QSk7XG4gICAgdW5pZm9ybXMuY29udHJvbEEudmFsdWUuY29weShjb250cm9sQSk7XG4gICAgdW5pZm9ybXMuY29udHJvbEIudmFsdWUuY29weShjb250cm9sQik7XG4gICAgdW5pZm9ybXMucG9pbnRCLnZhbHVlLmNvcHkocG9pbnRCKTtcbiAgICB1bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSByYWRpdXM7XG4gICAgdW5pZm9ybXMuZGFzaGluZy52YWx1ZS5zZXQoZGFzaEFycmF5LngsIGRhc2hBcnJheS55LCBkYXNoT2Zmc2V0IHx8IDApO1xuICB9XG5cbiAgcmF5Y2FzdCgvKnJheWNhc3RlciwgaW50ZXJzZWN0cyovKSB7XG4gICAgLy8gVE9ETyAtIGp1c3QgZmFpbCBmb3Igbm93XG4gIH1cbn1cblxuZXhwb3J0IHsgQmV6aWVyTWVzaCwgY3JlYXRlRGVyaXZlZE1hdGVyaWFsLCBleHBhbmRTaGFkZXJJbmNsdWRlcywgZ2V0U2hhZGVyVW5pZm9ybVR5cGVzLCBnZXRTaGFkZXJzRm9yTWF0ZXJpYWwsIGludmVydE1hdHJpeDQsIHZvaWRNYWluUmVnRXhwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\n");

/***/ })

};
;