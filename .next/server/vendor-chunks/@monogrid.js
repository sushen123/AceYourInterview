"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@monogrid";
exports.ids = ["vendor-chunks/@monogrid"];
exports.modules = {

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-6HrRQdJM.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-6HrRQdJM.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ QuadRenderer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.0.5\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */\n\n\n\nconst getBufferForType = (type, width, height) => {\n    let out;\n    switch (type) {\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error('Unsupported data type');\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n    if (_canReadPixelsResult !== undefined)\n        return _canReadPixelsResult;\n    const testRT = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({ color: 0xffffff }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */\n        this.render = () => {\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            }\n            catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type, // set in class property\n            colorSpace: this._colorSpace, // set in class property\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        }\n        else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this._camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch (this._type) {\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? three__WEBPACK_IMPORTED_MODULE_0__.FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${three__WEBPACK_IMPORTED_MODULE_0__.FloatType}`);\n                this._type = alternativeType;\n            }\n            else {\n                this._supportsReadPixels = false;\n                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n            }\n        }\n        this._quad = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : three__WEBPACK_IMPORTED_MODULE_0__.UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */\n    static instantiateRenderer() {\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */\n    toArray() {\n        if (!this._supportsReadPixels)\n            throw new Error('Can\\'t read pixels in this browser');\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @params options\n     * @returns\n     */\n    toDataTexture(options) {\n        const returnValue = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(\n        // fixed values\n        this.toArray(), this.width, this.height, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, this._type, \n        // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, \n        // fixed value\n        three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */\n    disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */\n    dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach(v => {\n                if (v.value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture)\n                    v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach(value => {\n            if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture)\n                value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */\n    get width() { return this._width; }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */\n    get height() { return this._height; }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */\n    get renderer() { return this._renderer; }\n    /**\n     * The `WebGLRenderTarget` used.\n     */\n    get renderTarget() { return this._renderTarget; }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n        // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */\n    get material() { return this._material; }\n    /**\n     *\n     */\n    get type() { return this._type; }\n    get colorSpace() { return this._colorSpace; }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9RdWFkUmVuZGVyZXItNkhyUlFkSk0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNlU7O0FBRTdVO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQWdCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhLGdEQUFhO0FBQzFCO0FBQ0E7QUFDQSxhQUFhLGtEQUFlO0FBQzVCO0FBQ0E7QUFDQSxhQUFhLDJDQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLDRDQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLDBDQUFPO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLDRDQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0RBQWlCO0FBQ3hDO0FBQ0EscUJBQXFCLHVDQUFJLEtBQUssZ0RBQWEsUUFBUSxvREFBaUIsR0FBRyxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxTkFBcU4sK0NBQVk7QUFDak8scU5BQXFOLCtDQUFZO0FBQ2pPO0FBQ0EseU1BQXlNLHNEQUFtQjtBQUM1Tix5TUFBeU0sc0RBQW1CO0FBQzVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBSztBQUMvQiwyQkFBMkIscURBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnREFBYTtBQUNsQyxnR0FBZ0csNENBQVM7QUFDekc7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFlBQVksOEJBQThCLDRDQUFTLENBQUM7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUNBQUksS0FBSyxnREFBYTtBQUMvQztBQUNBO0FBQ0EsaUNBQWlDLG9EQUFpQjtBQUNsRCx1T0FBdU8sNENBQVM7QUFDaFA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0RBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQVc7QUFDM0M7QUFDQSxpREFBaUQsNkNBQVU7QUFDM0Q7QUFDQSwrRUFBK0UsNENBQVMsdUVBQXVFLHNEQUFtQix1RUFBdUUsc0RBQW1CLDJFQUEyRSwrQ0FBWSwyRUFBMkUsK0NBQVk7QUFDMWI7QUFDQSxRQUFRLHVEQUFvQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGtDQUFrQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpREFBYztBQUNuRDtBQUNBLHVDQUF1QywwQ0FBTztBQUM5QztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMENBQU87QUFDeEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2Qjs7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXZlbGV2YXRlLy4vbm9kZV9tb2R1bGVzL0Btb25vZ3JpZC9nYWlubWFwLWpzL2Rpc3QvUXVhZFJlbmRlcmVyLTZIclJRZEpNLmpzPzZmNWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9ub2dyaWQvZ2Fpbm1hcC1qcyB2My4wLjVcbiAqIFdpdGgg4p2k77iPLCBieSBNT05PR1JJRCA8cm5kQG1vbm9ncmlkLmNvbT5cbiAqL1xuXG5pbXBvcnQgeyBSR0JBRm9ybWF0LCBMaW5lYXJGaWx0ZXIsIENsYW1wVG9FZGdlV3JhcHBpbmcsIFNjZW5lLCBPcnRob2dyYXBoaWNDYW1lcmEsIEhhbGZGbG9hdFR5cGUsIEZsb2F0VHlwZSwgTWVzaCwgUGxhbmVHZW9tZXRyeSwgV2ViR0xSZW5kZXJUYXJnZXQsIFVWTWFwcGluZywgV2ViR0xSZW5kZXJlciwgRGF0YVRleHR1cmUsIExpbmVhclNSR0JDb2xvclNwYWNlLCBTaGFkZXJNYXRlcmlhbCwgVGV4dHVyZSwgSW50VHlwZSwgU2hvcnRUeXBlLCBCeXRlVHlwZSwgVW5zaWduZWRJbnRUeXBlLCBVbnNpZ25lZEJ5dGVUeXBlLCBNZXNoQmFzaWNNYXRlcmlhbCB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgZ2V0QnVmZmVyRm9yVHlwZSA9ICh0eXBlLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgbGV0IG91dDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBVbnNpZ25lZEJ5dGVUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQxNkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBVbnNpZ25lZEludFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgVWludDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJ5dGVUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IEludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2hvcnRUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IEludDE2QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgSW50MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbmxldCBfY2FuUmVhZFBpeGVsc1Jlc3VsdDtcbi8qKlxuICogVGVzdCBpZiB0aGlzIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gY2FuIGNvcnJlY3RseSByZWFkIHBpeGVscyBmcm9tIHRoZSBzcGVjaWZpZWRcbiAqIFJlbmRlciB0YXJnZXQgdHlwZS5cbiAqXG4gKiBSdW5zIG9ubHkgb25jZVxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gcmVuZGVyZXJcbiAqIEBwYXJhbSBjYW1lcmFcbiAqIEBwYXJhbSByZW5kZXJUYXJnZXRPcHRpb25zXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBjYW5SZWFkUGl4ZWxzID0gKHR5cGUsIHJlbmRlcmVyLCBjYW1lcmEsIHJlbmRlclRhcmdldE9wdGlvbnMpID0+IHtcbiAgICBpZiAoX2NhblJlYWRQaXhlbHNSZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIF9jYW5SZWFkUGl4ZWxzUmVzdWx0O1xuICAgIGNvbnN0IHRlc3RSVCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCByZW5kZXJUYXJnZXRPcHRpb25zKTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGVzdFJUKTtcbiAgICBjb25zdCBtZXNoID0gbmV3IE1lc2gobmV3IFBsYW5lR2VvbWV0cnkoKSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmZmIH0pKTtcbiAgICByZW5kZXJlci5yZW5kZXIobWVzaCwgY2FtZXJhKTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgY29uc3Qgb3V0ID0gZ2V0QnVmZmVyRm9yVHlwZSh0eXBlLCB0ZXN0UlQud2lkdGgsIHRlc3RSVC5oZWlnaHQpO1xuICAgIHJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHModGVzdFJULCAwLCAwLCB0ZXN0UlQud2lkdGgsIHRlc3RSVC5oZWlnaHQsIG91dCk7XG4gICAgdGVzdFJULmRpc3Bvc2UoKTtcbiAgICBtZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBtZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICBfY2FuUmVhZFBpeGVsc1Jlc3VsdCA9IG91dFswXSAhPT0gMDtcbiAgICByZXR1cm4gX2NhblJlYWRQaXhlbHNSZXN1bHQ7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIHVzZWQgZm9yIHJlbmRlcmluZyBhIHRleHR1cmUgd2l0aCBhIG1hdGVyaWFsXG4gKlxuICogQGNhdGVnb3J5IENvcmVcbiAqIEBncm91cCBDb3JlXG4gKi9cbmNsYXNzIFF1YWRSZW5kZXJlciB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBRdWFkUmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFBhcmFtZXRlcnMgZm9yIHRoaXMgUXVhZFJlbmRlcmVyXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wLCBfcSwgX3I7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVySXNEaXNwb3NhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N1cHBvcnRzUmVhZFBpeGVscyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHRoZSBpbnB1dCB0ZXh0dXJlIHVzaW5nIHRoZSBzcGVjaWZpZWQgbWF0ZXJpYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHRoaXMuX3JlbmRlclRhcmdldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9zY2VuZSwgdGhpcy5fY2FtZXJhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dpZHRoID0gb3B0aW9ucy53aWR0aDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICAgIHRoaXMuX2NvbG9yU3BhY2UgPSBvcHRpb25zLmNvbG9yU3BhY2U7XG4gICAgICAgIGNvbnN0IHJ0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vIGZpeGVkIG9wdGlvbnNcbiAgICAgICAgICAgIGZvcm1hdDogUkdCQUZvcm1hdCxcbiAgICAgICAgICAgIGRlcHRoQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIHN0ZW5jaWxCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgLy8gdXNlciBvcHRpb25zXG4gICAgICAgICAgICB0eXBlOiB0aGlzLl90eXBlLCAvLyBzZXQgaW4gY2xhc3MgcHJvcGVydHlcbiAgICAgICAgICAgIGNvbG9yU3BhY2U6IHRoaXMuX2NvbG9yU3BhY2UsIC8vIHNldCBpbiBjbGFzcyBwcm9wZXJ0eVxuICAgICAgICAgICAgYW5pc290cm9weTogKChfYSA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFuaXNvdHJvcHkpICE9PSB1bmRlZmluZWQgPyAoX2IgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hbmlzb3Ryb3B5IDogMSxcbiAgICAgICAgICAgIGdlbmVyYXRlTWlwbWFwczogKChfYyA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdlbmVyYXRlTWlwbWFwcykgIT09IHVuZGVmaW5lZCA/IChfZCA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlLFxuICAgICAgICAgICAgbWFnRmlsdGVyOiAoKF9lID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubWFnRmlsdGVyKSAhPT0gdW5kZWZpbmVkID8gKF9mID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubWFnRmlsdGVyIDogTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgbWluRmlsdGVyOiAoKF9nID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubWluRmlsdGVyKSAhPT0gdW5kZWZpbmVkID8gKF9oID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2gubWluRmlsdGVyIDogTGluZWFyRmlsdGVyLFxuICAgICAgICAgICAgc2FtcGxlczogKChfaiA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnNhbXBsZXMpICE9PSB1bmRlZmluZWQgPyAoX2sgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5zYW1wbGVzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd3JhcFM6ICgoX2wgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9sID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbC53cmFwUykgIT09IHVuZGVmaW5lZCA/IChfbSA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLndyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcbiAgICAgICAgICAgIHdyYXBUOiAoKF9vID0gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28ud3JhcFQpICE9PSB1bmRlZmluZWQgPyAoX3AgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcC53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmdcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xuICAgICAgICBpZiAob3B0aW9ucy5yZW5kZXJlcikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBvcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBRdWFkUmVuZGVyZXIuaW5zdGFudGlhdGVSZW5kZXJlcigpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NjZW5lID0gbmV3IFNjZW5lKCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoKTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAxMCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYS5sZWZ0ID0gLTAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnJpZ2h0ID0gMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEudG9wID0gMC41O1xuICAgICAgICB0aGlzLl9jYW1lcmEuYm90dG9tID0gLTAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgaWYgKCFjYW5SZWFkUGl4ZWxzKHRoaXMuX3R5cGUsIHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9jYW1lcmEsIHJ0T3B0aW9ucykpIHtcbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlVHlwZSA9IHRoaXMuX3JlbmRlcmVyLmV4dGVuc2lvbnMuaGFzKCdFWFRfY29sb3JfYnVmZmVyX2Zsb2F0JykgPyBGbG9hdFR5cGUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsdGVybmF0aXZlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIHBpeGVscyBmcm9tICR7dGhpcy5fdHlwZX0gUmVuZGVyVGFyZ2V0cywgc3dpdGNoaW5nIHRvICR7RmxvYXRUeXBlfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBhbHRlcm5hdGl2ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0c1JlYWRQaXhlbHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgYnJvd3NlciBkb3Mgbm90IHN1cHBvcnQgdG9BcnJheSBvciB0b0RhdGFUZXh0dXJlLCBjYWxscyB0byB0aG9zZSBtZXRob2RzIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIHRocm93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3F1YWQgPSBuZXcgTWVzaChuZXcgUGxhbmVHZW9tZXRyeSgpLCB0aGlzLl9tYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuX3F1YWQuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG4gICAgICAgIHRoaXMuX3NjZW5lLmFkZCh0aGlzLl9xdWFkKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBydE9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQudGV4dHVyZS5tYXBwaW5nID0gKChfcSA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucykgPT09IG51bGwgfHwgX3EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9xLm1hcHBpbmcpICE9PSB1bmRlZmluZWQgPyAoX3IgPSBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnMpID09PSBudWxsIHx8IF9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfci5tYXBwaW5nIDogVVZNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSB0ZW1wb3JhcnkgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGluc3RhbnRpYXRlUmVuZGVyZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSgxMjgsIDEyOCk7XG4gICAgICAgIC8vIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZVxuICAgICAgICAvLyByZW5kZXJlci50b25lTWFwcGluZyA9IExpbmVhclRvbmVNYXBwaW5nXG4gICAgICAgIC8vIHJlbmRlcmVyLmRlYnVnLmNoZWNrU2hhZGVyRXJyb3JzID0gZmFsc2VcbiAgICAgICAgLy8gdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSB0cnVlXG4gICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2J0YWlucyBhIEJ1ZmZlciBjb250YWluaW5nIHRoZSByZW5kZXJlZCB0ZXh0dXJlLlxuICAgICAqXG4gICAgICogQHRocm93cyBFcnJvciBpZiB0aGUgYnJvd3NlciBjYW5ub3QgcmVhZCBwaXhlbHMgZnJvbSB0aGlzIFJlbmRlclRhcmdldCB0eXBlLlxuICAgICAqIEByZXR1cm5zIGEgVHlwZWRBcnJheSBjb250YWluaW5nIFJHQkEgdmFsdWVzIGZyb20gdGhpcyByZW5kZXJlclxuICAgICAqL1xuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3VwcG9ydHNSZWFkUGl4ZWxzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHJlYWQgcGl4ZWxzIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgICBjb25zdCBvdXQgPSBnZXRCdWZmZXJGb3JUeXBlKHRoaXMuX3R5cGUsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzKHRoaXMuX3JlbmRlclRhcmdldCwgMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgb3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSByZWFkUGl4ZWwgb3BlcmF0aW9uIGluIHRoZSByZW5kZXJUYXJnZXRcbiAgICAgKiBhbmQgcmV0dXJucyBhIERhdGFUZXh0dXJlIGNvbnRhaW5pbmcgdGhlIHJlYWQgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtcyBvcHRpb25zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICB0b0RhdGFUZXh0dXJlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBuZXcgRGF0YVRleHR1cmUoXG4gICAgICAgIC8vIGZpeGVkIHZhbHVlc1xuICAgICAgICB0aGlzLnRvQXJyYXkoKSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIFJHQkFGb3JtYXQsIHRoaXMuX3R5cGUsIFxuICAgICAgICAvLyB1c2VyIHZhbHVlc1xuICAgICAgICAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hcHBpbmcpIHx8IFVWTWFwcGluZywgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53cmFwUykgfHwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53cmFwVCkgfHwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYWdGaWx0ZXIpIHx8IExpbmVhckZpbHRlciwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW5GaWx0ZXIpIHx8IExpbmVhckZpbHRlciwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmlzb3Ryb3B5KSB8fCAxLCBcbiAgICAgICAgLy8gZml4ZWQgdmFsdWVcbiAgICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICAvLyBzZXQgdGhpcyBhZnRlcndhcmRzLCB3ZSBjYW4ndCBzZXQgaXQgaW4gY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuVmFsdWUuZ2VuZXJhdGVNaXBtYXBzID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5nZW5lcmF0ZU1pcG1hcHMpICE9PSB1bmRlZmluZWQgPyBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2VuZXJhdGVNaXBtYXBzIDogZmFsc2U7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdXNpbmcgYSBkaXNwb3NhYmxlIHJlbmRlcmVyLCBpdCB3aWxsIGRpc3Bvc2UgaXQuXG4gICAgICovXG4gICAgZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVySXNEaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5mb3JjZUNvbnRleHRMb3NzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCBkaXNwb3NlIG9mICoqYWxsKiogYXNzZXRzIHVzZWQgYnkgdGhpcyByZW5kZXJlci5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpc3Bvc2VSZW5kZXJUYXJnZXQgd2lsbCBkaXNwb3NlIG9mIHRoZSByZW5kZXJUYXJnZXQgd2hpY2ggd2lsbCBub3QgYmUgdXNhYmxlIGxhdGVyXG4gICAgICogc2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3UgcGFzc2VkIHRoZSBgcmVuZGVyVGFyZ2V0LnRleHR1cmVgIHRvIGEgYFBNUkVNR2VuZXJhdG9yYFxuICAgICAqIG9yIGFyZSBvdGhlcndpc2UgZG9uZSB3aXRoIGl0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IGxvYWRlciA9IG5ldyBIRFJKUEdMb2FkZXIocmVuZGVyZXIpXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGVnJylcbiAgICAgKiBjb25zdCBtZXNoID0gbmV3IE1lc2goZ2VvbWV0cnksIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlIH0pIClcbiAgICAgKiAvLyBETyBOT1QgZGlzcG9zZSB0aGUgcmVuZGVyVGFyZ2V0IGhlcmUsXG4gICAgICogLy8gaXQgaXMgdXNlZCBkaXJlY3RseSBpbiB0aGUgbWF0ZXJpYWxcbiAgICAgKiByZXN1bHQuZGlzcG9zZSgpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgbG9hZGVyID0gbmV3IEhEUkpQR0xvYWRlcihyZW5kZXJlcilcbiAgICAgKiBjb25zdCBwbXJlbUdlbmVyYXRvciA9IG5ldyBQTVJFTUdlbmVyYXRvciggcmVuZGVyZXIgKTtcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZWcnKVxuICAgICAqIGNvbnN0IGVudk1hcCA9IHBtcmVtR2VuZXJhdG9yLmZyb21FcXVpcmVjdGFuZ3VsYXIocmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlKVxuICAgICAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChnZW9tZXRyeSwgbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHsgZW52TWFwIH0pIClcbiAgICAgKiAvLyByZW5kZXJUYXJnZXQgY2FuIGJlIGRpc3Bvc2VkIGhlcmVcbiAgICAgKiAvLyBiZWNhdXNlIGl0IHdhcyB1c2VkIHRvIGdlbmVyYXRlIGEgUE1SRU0gdGV4dHVyZVxuICAgICAqIHJlc3VsdC5kaXNwb3NlKHRydWUpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGlzcG9zZShkaXNwb3NlUmVuZGVyVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgaWYgKGRpc3Bvc2VSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaXNwb3NlIHNoYWRlciBtYXRlcmlhbCB0ZXh0dXJlIHVuaWZvcm1zXG4gICAgICAgIGlmICh0aGlzLm1hdGVyaWFsIGluc3RhbmNlb2YgU2hhZGVyTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5tYXRlcmlhbC51bmlmb3JtcykuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodi52YWx1ZSBpbnN0YW5jZW9mIFRleHR1cmUpXG4gICAgICAgICAgICAgICAgICAgIHYudmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzcG9zZSBvdGhlciBtYXRlcmlhbCBwcm9wZXJ0aWVzXG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5tYXRlcmlhbCkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZXh0dXJlKVxuICAgICAgICAgICAgICAgIHZhbHVlLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9xdWFkLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIHRleHR1cmVcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7IHJldHVybiB0aGlzLl93aWR0aDsgfVxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQuc2V0U2l6ZSh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHsgcmV0dXJuIHRoaXMuX2hlaWdodDsgfVxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC5zZXRTaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVuZGVyZXIgdXNlZFxuICAgICAqL1xuICAgIGdldCByZW5kZXJlcigpIHsgcmV0dXJuIHRoaXMuX3JlbmRlcmVyOyB9XG4gICAgLyoqXG4gICAgICogVGhlIGBXZWJHTFJlbmRlclRhcmdldGAgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgcmVuZGVyVGFyZ2V0KCkgeyByZXR1cm4gdGhpcy5fcmVuZGVyVGFyZ2V0OyB9XG4gICAgc2V0IHJlbmRlclRhcmdldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZS53aWR0aDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWUuaGVpZ2h0O1xuICAgICAgICAvLyB0aGlzLl90eXBlID0gdmFsdWUudGV4dHVyZS50eXBlXG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgTWF0ZXJpYWxgIHVzZWQuXG4gICAgICovXG4gICAgZ2V0IG1hdGVyaWFsKCkgeyByZXR1cm4gdGhpcy5fbWF0ZXJpYWw7IH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCB0eXBlKCkgeyByZXR1cm4gdGhpcy5fdHlwZTsgfVxuICAgIGdldCBjb2xvclNwYWNlKCkgeyByZXR1cm4gdGhpcy5fY29sb3JTcGFjZTsgfVxufVxuXG5leHBvcnQgeyBRdWFkUmVuZGVyZXIgYXMgUSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-6HrRQdJM.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/decode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GainMapDecoderMaterial: () => (/* binding */ GainMapDecoderMaterial),\n/* harmony export */   GainMapLoader: () => (/* binding */ GainMapLoader),\n/* harmony export */   HDRJPGLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   JPEGRLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   MPFExtractor: () => (/* binding */ MPFExtractor),\n/* harmony export */   QuadRenderer: () => (/* reexport safe */ _QuadRenderer_6HrRQdJM_js__WEBPACK_IMPORTED_MODULE_1__.Q),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   extractGainmapFromJPEG: () => (/* binding */ extractGainmapFromJPEG),\n/* harmony export */   extractXMP: () => (/* binding */ extractXMP)\n/* harmony export */ });\n/* harmony import */ var _QuadRenderer_6HrRQdJM_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./QuadRenderer-6HrRQdJM.js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-6HrRQdJM.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.0.5\n * With ❤️, by MONOGRID <rnd@monogrid.com>\n */\n\n\n\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_0__.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n        console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n        sdr.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace) {\n        console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n        gainMap.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new _QuadRenderer_6HrRQdJM_js__WEBPACK_IMPORTED_MODULE_1__.Q({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n        colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getAttribute = (description, name, defaultValue) => {\n    var _a;\n    let returnValue;\n    const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n    if (!parsedValue) {\n        const node = description.getElementsByTagName(name)[0];\n        if (node) {\n            const values = node.getElementsByTagName('rdf:li');\n            if (values.length === 3) {\n                returnValue = Array.from(values).map(v => v.innerHTML);\n            }\n            else {\n                throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\n            }\n        }\n        else {\n            if (defaultValue)\n                return defaultValue;\n            else\n                throw new Error(`Can't find ${name} in gainmap metadata`);\n        }\n    }\n    else {\n        returnValue = parsedValue;\n    }\n    return returnValue;\n};\n/**\n *\n * @param input\n * @returns\n */\nconst extractXMP = (input) => {\n    var _a, _b;\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    const parser = new DOMParser();\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        str.slice(start, end + 10);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\n            const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\n            const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\n            const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\n            const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\n            let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\n            if (!hdrCapacityMin)\n                hdrCapacityMin = '0';\n            const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\n            if (!hdrCapacityMax)\n                throw new Error('Incomplete gainmap metadata');\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops 😵`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\nclass LoaderBase extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */\n    constructor(renderer, manager) {\n        super(manager);\n        if (renderer)\n            this._renderer = renderer;\n        this._internalLoadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */\n    prepareQuadRenderer() {\n        if (!this._renderer)\n            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new three__WEBPACK_IMPORTED_MODULE_0__.Texture(),\n            sdr: new three__WEBPACK_IMPORTED_MODULE_0__.Texture()\n        });\n        return new _QuadRenderer_6HrRQdJM_js__WEBPACK_IMPORTED_MODULE_1__.Q({\n            width: 16,\n            height: 16,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(gainMapImage || new ImageData(2, 2), three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(sdrImage, three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0Q7QUFDcU07O0FBRXBRO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpREFBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvSEFBb0g7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DLDJCQUEyQixnQkFBZ0I7QUFDM0MseUJBQXlCLFdBQVcsMENBQU8sa0RBQWtEO0FBQzdGLDZCQUE2QixXQUFXLDBDQUFPLHlCQUF5QjtBQUN4RSw2QkFBNkIsV0FBVywwQ0FBTyx5QkFBeUI7QUFDeEUsOEJBQThCLFdBQVcsMENBQU8sMEJBQTBCO0FBQzFFLDhCQUE4QixXQUFXLDBDQUFPLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCLDZDQUFVO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIseUJBQXlCO0FBQ3pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCO0FBQ0Es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ZXZlbGV2YXRlLy4vbm9kZV9tb2R1bGVzL0Btb25vZ3JpZC9nYWlubWFwLWpzL2Rpc3QvZGVjb2RlLmpzPzY0MjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9ub2dyaWQvZ2Fpbm1hcC1qcyB2My4wLjVcbiAqIFdpdGgg4p2k77iPLCBieSBNT05PR1JJRCA8cm5kQG1vbm9ncmlkLmNvbT5cbiAqL1xuXG5pbXBvcnQgeyBRIGFzIFF1YWRSZW5kZXJlciB9IGZyb20gJy4vUXVhZFJlbmRlcmVyLTZIclJRZEpNLmpzJztcbmltcG9ydCB7IFNoYWRlck1hdGVyaWFsLCBWZWN0b3IzLCBOb0JsZW5kaW5nLCBTUkdCQ29sb3JTcGFjZSwgTGluZWFyU1JHQkNvbG9yU3BhY2UsIEhhbGZGbG9hdFR5cGUsIExvYWRlciwgTG9hZGluZ01hbmFnZXIsIFRleHR1cmUsIFVWTWFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsIFJHQkFGb3JtYXQsIFVuc2lnbmVkQnl0ZVR5cGUsIEZpbGVMb2FkZXIgfSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IHZlcnRleFNoYWRlciA9IC8qIGdsc2wgKi8gYFxudmFyeWluZyB2ZWMyIHZVdjtcblxudm9pZCBtYWluKCkge1xuICB2VXYgPSB1djtcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcbn1cbmA7XG5jb25zdCBmcmFnbWVudFNoYWRlciA9IC8qIGdsc2wgKi8gYFxuLy8gbWluIGhhbGYgZmxvYXQgdmFsdWVcbiNkZWZpbmUgSEFMRl9GTE9BVF9NSU4gdmVjMyggLTY1NTA0LCAtNjU1MDQsIC02NTUwNCApXG4vLyBtYXggaGFsZiBmbG9hdCB2YWx1ZVxuI2RlZmluZSBIQUxGX0ZMT0FUX01BWCB2ZWMzKCA2NTUwNCwgNjU1MDQsIDY1NTA0IClcblxudW5pZm9ybSBzYW1wbGVyMkQgc2RyO1xudW5pZm9ybSBzYW1wbGVyMkQgZ2Fpbk1hcDtcbnVuaWZvcm0gdmVjMyBnYW1tYTtcbnVuaWZvcm0gdmVjMyBvZmZzZXRIZHI7XG51bmlmb3JtIHZlYzMgb2Zmc2V0U2RyO1xudW5pZm9ybSB2ZWMzIGdhaW5NYXBNaW47XG51bmlmb3JtIHZlYzMgZ2Fpbk1hcE1heDtcbnVuaWZvcm0gZmxvYXQgd2VpZ2h0RmFjdG9yO1xuXG52YXJ5aW5nIHZlYzIgdlV2O1xuXG52b2lkIG1haW4oKSB7XG4gIHZlYzMgcmdiID0gdGV4dHVyZTJEKCBzZHIsIHZVdiApLnJnYjtcbiAgdmVjMyByZWNvdmVyeSA9IHRleHR1cmUyRCggZ2Fpbk1hcCwgdlV2ICkucmdiO1xuICB2ZWMzIGxvZ1JlY292ZXJ5ID0gcG93KCByZWNvdmVyeSwgZ2FtbWEgKTtcbiAgdmVjMyBsb2dCb29zdCA9IGdhaW5NYXBNaW4gKiAoIDEuMCAtIGxvZ1JlY292ZXJ5ICkgKyBnYWluTWFwTWF4ICogbG9nUmVjb3Zlcnk7XG4gIHZlYzMgaGRyQ29sb3IgPSAocmdiICsgb2Zmc2V0U2RyKSAqIGV4cDIoIGxvZ0Jvb3N0ICogd2VpZ2h0RmFjdG9yICkgLSBvZmZzZXRIZHI7XG4gIHZlYzMgY2xhbXBlZEhkckNvbG9yID0gbWF4KCBIQUxGX0ZMT0FUX01JTiwgbWluKCBIQUxGX0ZMT0FUX01BWCwgaGRyQ29sb3IgKSk7XG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNsYW1wZWRIZHJDb2xvciAsIDEuMCApO1xufVxuYDtcbi8qKlxuICogQSBNYXRlcmlhbCB3aGljaCBpcyBhYmxlIHRvIGRlY29kZSB0aGUgR2Fpbm1hcCBpbnRvIGEgZnVsbCBIRFIgUmVwcmVzZW50YXRpb25cbiAqXG4gKiBAY2F0ZWdvcnkgTWF0ZXJpYWxzXG4gKiBAZ3JvdXAgTWF0ZXJpYWxzXG4gKi9cbmNsYXNzIEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBnYW1tYSwgb2Zmc2V0SGRyLCBvZmZzZXRTZHIsIGdhaW5NYXBNaW4sIGdhaW5NYXBNYXgsIG1heERpc3BsYXlCb29zdCwgaGRyQ2FwYWNpdHlNaW4sIGhkckNhcGFjaXR5TWF4LCBzZHIsIGdhaW5NYXAgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiAnR2Fpbk1hcERlY29kZXJNYXRlcmlhbCcsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICAgICAgc2RyOiB7IHZhbHVlOiBzZHIgfSxcbiAgICAgICAgICAgICAgICBnYWluTWFwOiB7IHZhbHVlOiBnYWluTWFwIH0sXG4gICAgICAgICAgICAgICAgZ2FtbWE6IHsgdmFsdWU6IG5ldyBWZWN0b3IzKDEuMCAvIGdhbW1hWzBdLCAxLjAgLyBnYW1tYVsxXSwgMS4wIC8gZ2FtbWFbMl0pIH0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0SGRyOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpLmZyb21BcnJheShvZmZzZXRIZHIpIH0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2RyOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpLmZyb21BcnJheShvZmZzZXRTZHIpIH0sXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1pbjogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoZ2Fpbk1hcE1pbikgfSxcbiAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpLmZyb21BcnJheShnYWluTWFwTWF4KSB9LFxuICAgICAgICAgICAgICAgIHdlaWdodEZhY3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKE1hdGgubG9nMihtYXhEaXNwbGF5Qm9vc3QpIC0gaGRyQ2FwYWNpdHlNaW4pIC8gKGhkckNhcGFjaXR5TWF4IC0gaGRyQ2FwYWNpdHlNaW4pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuICAgICAgICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tYXhEaXNwbGF5Qm9vc3QgPSBtYXhEaXNwbGF5Qm9vc3Q7XG4gICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWluID0gaGRyQ2FwYWNpdHlNaW47XG4gICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWF4ID0gaGRyQ2FwYWNpdHlNYXg7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGdldCBzZHIoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLnNkci52YWx1ZTsgfVxuICAgIHNldCBzZHIodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5zZHIudmFsdWUgPSB2YWx1ZTsgfVxuICAgIGdldCBnYWluTWFwKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5nYWluTWFwLnZhbHVlOyB9XG4gICAgc2V0IGdhaW5NYXAodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5nYWluTWFwLnZhbHVlID0gdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEub2Zmc2V0SGRyfVxuICAgICAqL1xuICAgIGdldCBvZmZzZXRIZHIoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldEhkci52YWx1ZS50b0FycmF5KCk7IH1cbiAgICBzZXQgb2Zmc2V0SGRyKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMub2Zmc2V0SGRyLnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEub2Zmc2V0U2RyfVxuICAgICAqL1xuICAgIGdldCBvZmZzZXRTZHIoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldFNkci52YWx1ZS50b0FycmF5KCk7IH1cbiAgICBzZXQgb2Zmc2V0U2RyKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMub2Zmc2V0U2RyLnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuZ2Fpbk1hcE1pbn1cbiAgICAgKi9cbiAgICBnZXQgZ2Fpbk1hcE1pbigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1pbi52YWx1ZS50b0FycmF5KCk7IH1cbiAgICBzZXQgZ2Fpbk1hcE1pbih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNaW4udmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5nYWluTWFwTWF4fVxuICAgICAqL1xuICAgIGdldCBnYWluTWFwTWF4KCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5nYWluTWFwTWF4LnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgIHNldCBnYWluTWFwTWF4KHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1heC52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmdhbW1hfVxuICAgICAqL1xuICAgIGdldCBnYW1tYSgpIHtcbiAgICAgICAgY29uc3QgZyA9IHRoaXMudW5pZm9ybXMuZ2FtbWEudmFsdWU7XG4gICAgICAgIHJldHVybiBbMSAvIGcueCwgMSAvIGcueSwgMSAvIGcuel07XG4gICAgfVxuICAgIHNldCBnYW1tYSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBnID0gdGhpcy51bmlmb3Jtcy5nYW1tYS52YWx1ZTtcbiAgICAgICAgZy54ID0gMS4wIC8gdmFsdWVbMF07XG4gICAgICAgIGcueSA9IDEuMCAvIHZhbHVlWzFdO1xuICAgICAgICBnLnogPSAxLjAgLyB2YWx1ZVsyXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmhkckNhcGFjaXR5TWlufVxuICAgICAqIEByZW1hcmtzIExvZ2FyaXRobWljIHNwYWNlXG4gICAgICovXG4gICAgZ2V0IGhkckNhcGFjaXR5TWluKCkgeyByZXR1cm4gdGhpcy5faGRyQ2FwYWNpdHlNaW47IH1cbiAgICBzZXQgaGRyQ2FwYWNpdHlNaW4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNaW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVXZWlnaHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmhkckNhcGFjaXR5TWlufVxuICAgICAqIEByZW1hcmtzIExvZ2FyaXRobWljIHNwYWNlXG4gICAgICovXG4gICAgZ2V0IGhkckNhcGFjaXR5TWF4KCkgeyByZXR1cm4gdGhpcy5faGRyQ2FwYWNpdHlNYXg7IH1cbiAgICBzZXQgaGRyQ2FwYWNpdHlNYXgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNYXggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVXZWlnaHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbm1hcERlY29kaW5nUGFyYW1ldGVycy5tYXhEaXNwbGF5Qm9vc3R9XG4gICAgICogQHJlbWFya3MgTm9uIExvZ2FyaXRobWljIHNwYWNlXG4gICAgICovXG4gICAgZ2V0IG1heERpc3BsYXlCb29zdCgpIHsgcmV0dXJuIHRoaXMuX21heERpc3BsYXlCb29zdDsgfVxuICAgIHNldCBtYXhEaXNwbGF5Qm9vc3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWF4RGlzcGxheUJvb3N0ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oNjU1MDQsIHZhbHVlKSk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlV2VpZ2h0KCk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZVdlaWdodCgpIHtcbiAgICAgICAgY29uc3QgdmFsID0gKE1hdGgubG9nMih0aGlzLl9tYXhEaXNwbGF5Qm9vc3QpIC0gdGhpcy5faGRyQ2FwYWNpdHlNaW4pIC8gKHRoaXMuX2hkckNhcGFjaXR5TWF4IC0gdGhpcy5faGRyQ2FwYWNpdHlNaW4pO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLndlaWdodEZhY3Rvci52YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgZ2FpbiBtYXAgdXNpbmcgYSBXZWJHTFJlbmRlclRhcmdldFxuICpcbiAqIEBjYXRlZ29yeSBEZWNvZGluZyBGdW5jdGlvbnNcbiAqIEBncm91cCBEZWNvZGluZyBGdW5jdGlvbnNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcydcbiAqIGltcG9ydCB7XG4gKiAgIE1lc2gsXG4gKiAgIE1lc2hCYXNpY01hdGVyaWFsLFxuICogICBQZXJzcGVjdGl2ZUNhbWVyYSxcbiAqICAgUGxhbmVHZW9tZXRyeSxcbiAqICAgU2NlbmUsXG4gKiAgIFRleHR1cmVMb2FkZXIsXG4gKiAgIFdlYkdMUmVuZGVyZXJcbiAqIH0gZnJvbSAndGhyZWUnXG4gKlxuICogY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpXG4gKlxuICogY29uc3QgdGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKClcbiAqXG4gKiAvLyBsb2FkIFNEUiBSZXByZXNlbnRhdGlvblxuICogY29uc3Qgc2RyID0gYXdhaXQgdGV4dHVyZUxvYWRlci5sb2FkQXN5bmMoJ3Nkci5qcGcnKVxuICogLy8gbG9hZCBHYWluIG1hcCByZWNvdmVyeSBpbWFnZVxuICogY29uc3QgZ2Fpbk1hcCA9IGF3YWl0IHRleHR1cmVMb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZycpXG4gKiAvLyBsb2FkIG1ldGFkYXRhXG4gKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IChhd2FpdCBmZXRjaCgnbWV0YWRhdGEuanNvbicpKS5qc29uKClcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBkZWNvZGUoe1xuICogICBzZHIsXG4gKiAgIGdhaW5NYXAsXG4gKiAgIC8vIHRoaXMgYWxsb3dzIHRvIHVzZSBgcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlYCBkaXJlY3RseVxuICogICByZW5kZXJlcixcbiAqICAgLy8gdGhpcyB3aWxsIHJlc3RvcmUgdGhlIGZ1bGwgSERSIHJhbmdlXG4gKiAgIG1heERpc3BsYXlCb29zdDogTWF0aC5wb3coMiwgbWV0YWRhdGEuaGRyQ2FwYWNpdHlNYXgpLFxuICogICAuLi5tZXRhZGF0YVxuICogfSlcbiAqXG4gKiBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpXG4gKiAvLyBgcmVzdWx0YCBjYW4gYmUgdXNlZCB0byBwb3B1bGF0ZSBhIFRleHR1cmVcbiAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAqICAgbmV3IFBsYW5lR2VvbWV0cnkoKSxcbiAqICAgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSlcbiAqIClcbiAqIHNjZW5lLmFkZChtZXNoKVxuICogcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKSlcbiAqXG4gKiAvLyByZXN1bHQgbXVzdCBiZSBtYW51YWxseSBkaXNwb3NlZFxuICogLy8gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgaXRcbiAqIHJlc3VsdC5kaXNwb3NlKClcbiAqXG4gKiBAcGFyYW0gcGFyYW1zXG4gKiBAcmV0dXJuc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBXZWJHTFJlbmRlcmVyIGZhaWxzIHRvIHJlbmRlciB0aGUgZ2FpbiBtYXBcbiAqL1xuY29uc3QgZGVjb2RlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgc2RyLCBnYWluTWFwLCByZW5kZXJlciB9ID0gcGFyYW1zO1xuICAgIGlmIChzZHIuY29sb3JTcGFjZSAhPT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdTRFIgQ29sb3JzcGFjZSBuZWVkcyB0byBiZSAqU1JHQkNvbG9yU3BhY2UqLCBzZXR0aW5nIGl0IGF1dG9tYXRpY2FsbHknKTtcbiAgICAgICAgc2RyLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTtcbiAgICB9XG4gICAgc2RyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBpZiAoZ2Fpbk1hcC5jb2xvclNwYWNlICE9PSBMaW5lYXJTUkdCQ29sb3JTcGFjZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0dhaW5tYXAgQ29sb3JzcGFjZSBuZWVkcyB0byBiZSAqTGluZWFyU1JHQkNvbG9yU3BhY2UqLCBzZXR0aW5nIGl0IGF1dG9tYXRpY2FsbHknKTtcbiAgICAgICAgZ2Fpbk1hcC5jb2xvclNwYWNlID0gTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgfVxuICAgIGdhaW5NYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwoe1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHNkcixcbiAgICAgICAgZ2Fpbk1hcFxuICAgIH0pO1xuICAgIGNvbnN0IHF1YWRSZW5kZXJlciA9IG5ldyBRdWFkUmVuZGVyZXIoe1xuICAgICAgICAvLyBUT0RPOiB0aHJlZSB0eXBlcyBhcmUgZ2VuZXJpYywgZXNsaW50IGNvbXBsYWlucyBoZXJlLCBzZWUgaG93IHdlIGNhbiBzb2x2ZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgd2lkdGg6IHNkci5pbWFnZS53aWR0aCxcbiAgICAgICAgLy8gVE9ETzogdGhyZWUgdHlwZXMgYXJlIGdlbmVyaWMsIGVzbGludCBjb21wbGFpbnMgaGVyZSwgc2VlIGhvdyB3ZSBjYW4gc29sdmVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIGhlaWdodDogc2RyLmltYWdlLmhlaWdodCxcbiAgICAgICAgdHlwZTogSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgY29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gICAgICAgIG1hdGVyaWFsLFxuICAgICAgICByZW5kZXJlcixcbiAgICAgICAgcmVuZGVyVGFyZ2V0T3B0aW9uczogcGFyYW1zLnJlbmRlclRhcmdldE9wdGlvbnNcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgICBxdWFkUmVuZGVyZXIucmVuZGVyKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gcXVhZFJlbmRlcmVyO1xufTtcblxuY2xhc3MgR2Fpbk1hcE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbmNsYXNzIFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cblxuY29uc3QgZ2V0QXR0cmlidXRlID0gKGRlc2NyaXB0aW9uLCBuYW1lLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHJldHVyblZhbHVlO1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gKF9hID0gZGVzY3JpcHRpb24uYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0obmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub2RlVmFsdWU7XG4gICAgaWYgKCFwYXJzZWRWYWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZGVzY3JpcHRpb24uZ2V0RWxlbWVudHNCeVRhZ05hbWUobmFtZSlbMF07XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdyZGY6bGknKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBBcnJheS5mcm9tKHZhbHVlcykubWFwKHYgPT4gdi5pbm5lckhUTUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHYWlubWFwIG1ldGFkYXRhIGNvbnRhaW5zIGFuIGFycmF5IG9mIGl0ZW1zIGZvciAke25hbWV9IGJ1dCBpdHMgbGVuZ3RoIGlzIG5vdCAzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kICR7bmFtZX0gaW4gZ2Fpbm1hcCBtZXRhZGF0YWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm5WYWx1ZSA9IHBhcnNlZFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIGlucHV0XG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBleHRyYWN0WE1QID0gKGlucHV0KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgc3RyO1xuICAgIC8vIHN1cHBvcnQgbm9kZSB0ZXN0IGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHN0ciA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShpbnB1dCk7XG4gICAgZWxzZVxuICAgICAgICBzdHIgPSBpbnB1dC50b1N0cmluZygpO1xuICAgIGxldCBzdGFydCA9IHN0ci5pbmRleE9mKCc8eDp4bXBtZXRhJyk7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgIHdoaWxlIChzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgZW5kID0gc3RyLmluZGV4T2YoJ3g6eG1wbWV0YT4nLCBzdGFydCk7XG4gICAgICAgIHN0ci5zbGljZShzdGFydCwgZW5kICsgMTApO1xuICAgICAgICBjb25zdCB4bXBCbG9jayA9IHN0ci5zbGljZShzdGFydCwgZW5kICsgMTApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeG1sRG9jdW1lbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtcEJsb2NrLCAndGV4dC94bWwnKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0geG1sRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3JkZjpEZXNjcmlwdGlvbicpWzBdO1xuICAgICAgICAgICAgY29uc3QgZ2Fpbk1hcE1pbiA9IGdldEF0dHJpYnV0ZShkZXNjcmlwdGlvbiwgJ2hkcmdtOkdhaW5NYXBNaW4nLCAnMCcpO1xuICAgICAgICAgICAgY29uc3QgZ2Fpbk1hcE1heCA9IGdldEF0dHJpYnV0ZShkZXNjcmlwdGlvbiwgJ2hkcmdtOkdhaW5NYXBNYXgnKTtcbiAgICAgICAgICAgIGNvbnN0IGdhbW1hID0gZ2V0QXR0cmlidXRlKGRlc2NyaXB0aW9uLCAnaGRyZ206R2FtbWEnLCAnMScpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0U0RSID0gZ2V0QXR0cmlidXRlKGRlc2NyaXB0aW9uLCAnaGRyZ206T2Zmc2V0U0RSJywgJzAuMDE1NjI1Jyk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRIRFIgPSBnZXRBdHRyaWJ1dGUoZGVzY3JpcHRpb24sICdoZHJnbTpPZmZzZXRIRFInLCAnMC4wMTU2MjUnKTtcbiAgICAgICAgICAgIGxldCBoZHJDYXBhY2l0eU1pbiA9IChfYSA9IGRlc2NyaXB0aW9uLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdoZHJnbTpIRFJDYXBhY2l0eU1pbicpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZVZhbHVlO1xuICAgICAgICAgICAgaWYgKCFoZHJDYXBhY2l0eU1pbilcbiAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1pbiA9ICcwJztcbiAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWF4ID0gKF9iID0gZGVzY3JpcHRpb24uYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2hkcmdtOkhEUkNhcGFjaXR5TWF4JykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ub2RlVmFsdWU7XG4gICAgICAgICAgICBpZiAoIWhkckNhcGFjaXR5TWF4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wbGV0ZSBnYWlubWFwIG1ldGFkYXRhJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IEFycmF5LmlzQXJyYXkoZ2Fpbk1hcE1pbikgPyBnYWluTWFwTWluLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQoZ2Fpbk1hcE1pbiksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1pbiksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1pbildLFxuICAgICAgICAgICAgICAgIGdhaW5NYXBNYXg6IEFycmF5LmlzQXJyYXkoZ2Fpbk1hcE1heCkgPyBnYWluTWFwTWF4Lm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQoZ2Fpbk1hcE1heCksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1heCksIHBhcnNlRmxvYXQoZ2Fpbk1hcE1heCldLFxuICAgICAgICAgICAgICAgIGdhbW1hOiBBcnJheS5pc0FycmF5KGdhbW1hKSA/IGdhbW1hLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQoZ2FtbWEpLCBwYXJzZUZsb2F0KGdhbW1hKSwgcGFyc2VGbG9hdChnYW1tYSldLFxuICAgICAgICAgICAgICAgIG9mZnNldFNkcjogQXJyYXkuaXNBcnJheShvZmZzZXRTRFIpID8gb2Zmc2V0U0RSLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQob2Zmc2V0U0RSKSwgcGFyc2VGbG9hdChvZmZzZXRTRFIpLCBwYXJzZUZsb2F0KG9mZnNldFNEUildLFxuICAgICAgICAgICAgICAgIG9mZnNldEhkcjogQXJyYXkuaXNBcnJheShvZmZzZXRIRFIpID8gb2Zmc2V0SERSLm1hcCh2ID0+IHBhcnNlRmxvYXQodikpIDogW3BhcnNlRmxvYXQob2Zmc2V0SERSKSwgcGFyc2VGbG9hdChvZmZzZXRIRFIpLCBwYXJzZUZsb2F0KG9mZnNldEhEUildLFxuICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWluOiBwYXJzZUZsb2F0KGhkckNhcGFjaXR5TWluKSxcbiAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1heDogcGFyc2VGbG9hdChoZHJDYXBhY2l0eU1heClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IHN0ci5pbmRleE9mKCc8eDp4bXBtZXRhJywgZW5kKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1QRiBFeHRyYWN0b3IgKE11bHRpIFBpY3R1cmUgRm9ybWF0IEV4dHJhY3RvcilcbiAqIEJ5IEhlbnJpayBTIE5pbHNzb24gMjAxOVxuICpcbiAqIEV4dHJhY3RzIGltYWdlcyBzdG9yZWQgaW4gaW1hZ2VzIGJhc2VkIG9uIHRoZSBNUEYgZm9ybWF0IChmb3VuZCBoZXJlOiBodHRwczovL3d3dy5jaXBhLmpwL2Uvc3RkL3N0ZC1zZWMuaHRtbFxuICogdW5kZXIgXCJDSVBBIERDLTAwNy1UcmFuc2xhdGlvbi0yMDIxIE11bHRpLVBpY3R1cmUgRm9ybWF0XCJcbiAqXG4gKiBPdmVybHkgY29tbWVudGVkLCBhbmQgd2l0aG91dCBpbnRlbnRpb24gb2YgYmVpbmcgY29tcGxldGUgb3IgcHJvZHVjdGlvbiByZWFkeS5cbiAqIENyZWF0ZWQgdG8gZXh0cmFjdCBkZXB0aCBtYXBzIGZyb20gaVBob25lIGltYWdlcywgYW5kIHRvIGxlYXJuIGFib3V0IGltYWdlIG1ldGFkYXRhLlxuICogS3Vkb3MgdG86IFBoaWwgSGFydmV5IChleGlmdG9vbCksIEphdW1lIFNhbmNoZXogKGFuZHJvaWQtbGVucy1ibHVyLWRlcHRoLWV4dHJhY3RvcilcbiAqL1xuY2xhc3MgTVBGRXh0cmFjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRlYnVnOiBvcHRpb25zICYmIG9wdGlvbnMuZGVidWcgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVidWcgOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dHJhY3RGSUk6IG9wdGlvbnMgJiYgb3B0aW9ucy5leHRyYWN0RklJICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmV4dHJhY3RGSUkgOiB0cnVlLFxuICAgICAgICAgICAgZXh0cmFjdE5vbkZJSTogb3B0aW9ucyAmJiBvcHRpb25zLmV4dHJhY3ROb25GSUkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0cmFjdE5vbkZJSSA6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXh0cmFjdChpbWFnZUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWJ1ZyA9IHRoaXMub3B0aW9ucy5kZWJ1ZztcbiAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGltYWdlQXJyYXlCdWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgIC8vIElmIHlvdSdyZSBleGVjdXRpbmcgdGhpcyBsaW5lIG9uIGEgYmlnIGVuZGlhbiBtYWNoaW5lLCBpdCdsbCBiZSByZXZlcnNlZC5cbiAgICAgICAgICAgIC8vIGJpZ0VuZCBmdXJ0aGVyIGRvd24gdGhvdWdoLCByZWZlcnMgdG8gdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGltYWdlIGl0c2VsZi5cbiAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYoMCkgIT09IDB4ZmZkOCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGpwZWcnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAyO1xuICAgICAgICAgICAgbGV0IGxvb3BzID0gMDtcbiAgICAgICAgICAgIGxldCBtYXJrZXI7IC8vIEFQUCMgbWFya2VyXG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrbG9vcHMgPiAyNTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRm91bmQgbm8gbWFya2VyIGFmdGVyICR7bG9vcHN9IGxvb3BzIPCfmLVgKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCkgIT09IDB4ZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgTm90IGEgdmFsaWQgbWFya2VyIGF0IG9mZnNldCAweCR7b2Zmc2V0LnRvU3RyaW5nKDE2KX0sIGZvdW5kOiAweCR7ZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KS50b1N0cmluZygxNil9YCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmtlciA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1hcmtlcjogJHttYXJrZXIudG9TdHJpbmcoMTYpfWApO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXIgPT09IDB4ZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIEFQUDIgbWFya2VyICgweGZmZTIpJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmtzIGZvciBpUGhvbmUgOCBQbHVzLCBYLCBhbmQgWFNNYXguIE9yIGFueSBwaG90b3Mgb2YgTVBGIGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gR3JlYXQgd2F5IHRvIHZpc3VhbGl6ZSBpbWFnZSBpbmZvcm1hdGlvbiBpbiBodG1sIGlzIHVzaW5nIEV4aWZ0b29sLiBFLmcuOlxuICAgICAgICAgICAgICAgICAgICAvLyAuL2V4aWZ0b29sLmV4ZSAtaHRtbGR1bXAgLXdhbnRUcmFpbGVyIHBob3RvLmpwZyA+IHBob3RvLmh0bWxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0UHQgPSBvZmZzZXQgKyA0O1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiAgU3RydWN0dXJlIG9mIHRoZSBNUCBGb3JtYXQgSWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiAgT2Zmc2V0IEFkZHIuICB8IENvZGUgKEhleCkgIHwgRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICogICswMCAgICAgICAgICAgICBmZiAgICAgICAgICAgIE1hcmtlciBQcmVmaXggICAgICA8LS0gb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAqICArMDEgICAgICAgICAgICAgZTIgICAgICAgICAgICBBUFAyXG4gICAgICAgICAgICAgICAgICAgICAqICArMDIgICAgICAgICAgICAgI24gICAgICAgICAgICBBUFAyIEZpZWxkIExlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgKiAgKzAzICAgICAgICAgICAgICNuICAgICAgICAgICAgQVBQMiBGaWVsZCBMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICogICswNCAgICAgICAgICAgICA0ZCAgICAgICAgICAgICdNJyAgICAgICAgICAgICAgICA8LS0gZm9ybWF0UHRcbiAgICAgICAgICAgICAgICAgICAgICogICswNSAgICAgICAgICAgICA1MCAgICAgICAgICAgICdQJ1xuICAgICAgICAgICAgICAgICAgICAgKiAgKzA2ICAgICAgICAgICAgIDQ2ICAgICAgICAgICAgJ0YnXG4gICAgICAgICAgICAgICAgICAgICAqICArMDcgICAgICAgICAgICAgMDAgICAgICAgICAgICBOVUxMXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tIHRpZmZPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIoZm9ybWF0UHQpID09PSAweDRkNTA0NjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3VuZCBNUEYgdGFnLCBzbyB3ZSBzdGFydCBkaWcgb3V0IHN1YiBpbWFnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpZmZPZmZzZXQgPSBmb3JtYXRQdCArIDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmlnRW5kOyAvLyBFbmRpYW5uZXNzIGZyb20gVElGRiBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlc3QgZm9yIFRJRkYgdmFsaWRpdHkgYW5kIGVuZGlhbm5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDB4NDk0OSBhbmQgMHg0RDREICgnSUknIGFuZCAnTU0nKSBtYXJrcyBMaXR0bGUgRW5kaWFuIGFuZCBCaWcgRW5kaWFuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWdFbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0ZDRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlnRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vIHZhbGlkIGVuZGlhbm5lc3MgbWFya2VyIGZvdW5kIGluIFRJRkYgaGVhZGVyJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCArIDIsICFiaWdFbmQpICE9PSAweDAwMmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdOb3QgdmFsaWQgVElGRiBkYXRhISAobm8gMHgwMDJBIG1hcmtlciknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMzIgYml0IG51bWJlciBzdGF0aW5nIHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIDggQnl0ZSBNUCBIZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIE1QIEluZGV4IElGRCBMZWFzdCBwb3NzaWJsZSB2YWx1ZSBpcyB0aHVzIDggKG1lYW5zIDAgb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBkYXRhVmlldy5nZXRVaW50MzIodGlmZk9mZnNldCArIDQsICFiaWdFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCB2YWxpZCBUSUZGIGRhdGEhIChGaXJzdCBvZmZzZXQgbGVzcyB0aGFuIDgpJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgYWhlYWQgdG8gTVAgSW5kZXggSUZEXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgd2UncmUgYXQgdGhlIGZpcnN0IElGRCwgc28gZmlyc3RJRkRPZmZzZXQgcG9pbnRzIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNUCBJbmRleCBJRkQgYW5kIG5vdCBNUCBBdHRyaWJ1dGVzIElGRC4gKElmIHdlIHRyeSBleHRyYWN0IGZyb20gYSBzdWIgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmYWlsIHNpbGVudGx5IGhlcmUgZHVlIHRvIHRoaXMgYXNzdW1wdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvdW50ICgyIEJ5dGUpIHwgTVAgSW5kZXggRmllbGRzIGEuay5hLiBNUCBFbnRyaWVzIChjb3VudCAqIDEyIEJ5dGUpIHwgT2Zmc2V0IG9mIE5leHQgSUZEICg0IEJ5dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJTdGFydCA9IHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldDsgLy8gU3RhcnQgb2YgSUZEIChJbWFnZSBGaWxlIERpcmVjdG9yeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZGF0YVZpZXcuZ2V0VWludDE2KGRpclN0YXJ0LCAhYmlnRW5kKTsgLy8gQ291bnQgb2YgTVBFbnRyaWVzICgyIEJ5dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGluZm8gZnJvbSBNUEVudHJpZXMgKHN0YXJ0aW5nIGFmdGVyIENvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllc1N0YXJ0ID0gZGlyU3RhcnQgKyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG51bWJlck9mSW1hZ2VzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBlbnRyaWVzU3RhcnQ7IGkgPCBlbnRyaWVzU3RhcnQgKyAxMiAqIGNvdW50OyBpICs9IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBlbnRyeSBpcyAxMiBCeXRlcyBsb25nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgTVAgSW5kZXggSUZEIHRhZ3MsIGhlcmUgd2Ugb25seSB0YWtlIHRhZyAweGIwMDEgPSBOdW1iZXIgb2YgaW1hZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNihpLCAhYmlnRW5kKSA9PT0gMHhiMDAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlZCBpbiBMYXN0IDQgYnl0ZXMgb2YgaXRzIDEyIEJ5dGUgZW50cnkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlck9mSW1hZ2VzID0gZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA4LCAhYmlnRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SUZET2Zmc2V0TGVuID0gNDsgLy8gNCBCeXRlIG9mZnNldCBmaWVsZCB0aGF0IGFwcGVhcnMgYWZ0ZXIgTVAgSW5kZXggSUZEIHRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IE1QSW1hZ2VMaXN0VmFsUHQgPSBkaXJTdGFydCArIDIgKyBjb3VudCAqIDEyICsgbmV4dElGRE9mZnNldExlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IE1QSW1hZ2VMaXN0VmFsUHQ7IGkgPCBNUEltYWdlTGlzdFZhbFB0ICsgbnVtYmVyT2ZJbWFnZXMgKiAxNjsgaSArPSAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNUFR5cGU6IGRhdGFWaWV3LmdldFVpbnQzMihpLCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA0LCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBvZmZzZXQgaXMgc3BlY2lmaWVkIHJlbGF0aXZlIHRvIHRoZSBhZGRyZXNzIG9mIHRoZSBNUCBFbmRpYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgaW4gdGhlIE1QIEhlYWRlciwgdW5sZXNzIHRoZSBpbWFnZSBpcyBhIEZpcnN0IEluZGl2aWR1YWwgSW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIHdoaWNoIGNhc2UgdGhlIHZhbHVlIG9mIHRoZSBvZmZzZXQgc2hhbGwgYmUgTlVMTCAoMHgwMDAwMDAwMCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFPZmZzZXQ6IGRhdGFWaWV3LmdldFVpbnQzMihpICsgOCwgIWJpZ0VuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGFudEltYWdlczogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyAxMiwgIWJpZ0VuZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNGSUk6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWltYWdlLmRhdGFPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGF0YU9mZnNldCBpcyAweDAwMDAwMDAwIGZvciBGaXJzdCBJbmRpdmlkdWFsIEltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuaXNGSUkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3RhcnQgPSB0aWZmT2Zmc2V0ICsgaW1hZ2UuZGF0YU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuaXNGSUkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UuZW5kID0gaW1hZ2Uuc3RhcnQgKyBpbWFnZS5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlcy5wdXNoKGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0cmFjdE5vbkZJSSAmJiBpbWFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyQmxvYiA9IG5ldyBCbG9iKFtkYXRhVmlld10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGltYWdlIG9mIGltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuaXNGSUkgJiYgIXRoaXMub3B0aW9ucy5leHRyYWN0RklJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCBGSUlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSBidWZmZXJCbG9iLnNsaWNlKGltYWdlLnN0YXJ0LCBpbWFnZS5lbmQgKyAxLCAnaW1hZ2UvanBlZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgaW1hZ2VVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGltYWdlQmxvYilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2UuaW1nLnNyYyA9IGltYWdlVXJsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltZ3MucHVzaChpbWFnZUJsb2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGltZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyICsgZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgWE1QIE1ldGFkYXRhIGFuZCB0aGUgZ2FpbiBtYXAgcmVjb3ZlcnkgaW1hZ2VcbiAqIGZyb20gYSBzaW5nbGUgSlBFRyBmaWxlLlxuICpcbiAqIEBjYXRlZ29yeSBEZWNvZGluZyBGdW5jdGlvbnNcbiAqIEBncm91cCBEZWNvZGluZyBGdW5jdGlvbnNcbiAqIEBwYXJhbSBqcGVnRmlsZSBhbiBgVWludDhBcnJheWAgY29udGFpbmluZyBhbmQgZW5jb2RlZCBKUEVHIGZpbGVcbiAqIEByZXR1cm5zIGFuIHNkciBgVWludDhBcnJheWAgY29tcHJlc3NlZCBpbiBKUEVHLCBhIGdhaW5NYXAgYFVpbnQ4QXJyYXlgIGNvbXByZXNzZWQgaW4gSlBFRyBhbmQgdGhlIFhNUCBwYXJzZWQgWE1QIG1ldGFkYXRhXG4gKiBAdGhyb3dzIEVycm9yIGlmIFhNUCBNZXRhZGF0YSBpcyBub3QgZm91bmRcbiAqIEB0aHJvd3MgRXJyb3IgaWYgR2FpbiBtYXAgaW1hZ2UgaXMgbm90IGZvdW5kXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRmlsZUxvYWRlciB9IGZyb20gJ3RocmVlJ1xuICogaW1wb3J0IHsgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICpcbiAqIGNvbnN0IGpwZWdGaWxlID0gYXdhaXQgbmV3IEZpbGVMb2FkZXIoKVxuICogIC5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJylcbiAqICAubG9hZEFzeW5jKCdpbWFnZS5qcGcnKVxuICpcbiAqIGNvbnN0IHsgc2RyLCBnYWluTWFwLCBtZXRhZGF0YSB9ID0gZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyhqcGVnRmlsZSlcbiAqL1xuY29uc3QgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyA9IGFzeW5jIChqcGVnRmlsZSkgPT4ge1xuICAgIGNvbnN0IG1ldGFkYXRhID0gZXh0cmFjdFhNUChqcGVnRmlsZSk7XG4gICAgaWYgKCFtZXRhZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvcignR2FpbiBtYXAgWE1QIG1ldGFkYXRhIG5vdCBmb3VuZCcpO1xuICAgIGNvbnN0IG1wZkV4dHJhY3RvciA9IG5ldyBNUEZFeHRyYWN0b3IoeyBleHRyYWN0RklJOiB0cnVlLCBleHRyYWN0Tm9uRklJOiB0cnVlIH0pO1xuICAgIGNvbnN0IGltYWdlcyA9IGF3YWl0IG1wZkV4dHJhY3Rvci5leHRyYWN0KGpwZWdGaWxlKTtcbiAgICBpZiAoaW1hZ2VzLmxlbmd0aCAhPT0gMilcbiAgICAgICAgdGhyb3cgbmV3IEdhaW5NYXBOb3RGb3VuZEVycm9yKCdHYWluIG1hcCByZWNvdmVyeSBpbWFnZSBub3QgZm91bmQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZHI6IG5ldyBVaW50OEFycmF5KGF3YWl0IGltYWdlc1swXS5hcnJheUJ1ZmZlcigpKSxcbiAgICAgICAgZ2Fpbk1hcDogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgaW1hZ2VzWzFdLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICBtZXRhZGF0YVxuICAgIH07XG59O1xuXG4vKipcbiAqIHByaXZhdGUgZnVuY3Rpb24sIGFzeW5jIGdldCBpbWFnZSBmcm9tIGJsb2JcbiAqXG4gKiBAcGFyYW0gYmxvYlxuICogQHJldHVybnNcbiAqL1xuY29uc3QgZ2V0SFRNTEltYWdlRnJvbUJsb2IgPSAoYmxvYikgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4geyByZXNvbHZlKGltZyk7IH07XG4gICAgICAgIGltZy5vbmVycm9yID0gKGUpID0+IHsgcmVqZWN0KGUpOyB9O1xuICAgICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB9KTtcbn07XG5cbmNsYXNzIExvYWRlckJhc2UgZXh0ZW5kcyBMb2FkZXIge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbmRlcmVyXG4gICAgICogQHBhcmFtIG1hbmFnZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgbWFuYWdlcikge1xuICAgICAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICAgICAgaWYgKHJlbmRlcmVyKVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSByZW5kZXJlciB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGdhaW4gbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHNldFJlbmRlcmVyKHJlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSByZW5kZXJUYXJnZXQgb3B0aW9ucyB0byB1c2Ugd2hlbiByZW5kZXJpbmcgdGhlIGdhaW4gbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc2V0UmVuZGVyVGFyZ2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHByZXBhcmVRdWFkUmVuZGVyZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IEFuIGV4aXN0aW5nIFdlYkdMIFJlbmRlcmVyIHdhcyBub3QgcGFzc2VkIHRvIHRoaXMgTG9hZGVyIGNvbnN0cnVjdG9yIG9yIGluIHNldFJlbmRlcmVyLCB0aGUgcmVzdWx0IG9mIHRoaXMgTG9hZGVyIHdpbGwgbmVlZCB0byBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhIFRleHR1cmUgd2l0aCB0b0RhdGFUZXh0dXJlKCkgYmVmb3JlIHlvdSBjYW4gdXNlIGl0IGluIHlvdXIgcmVuZGVyZXIuJyk7XG4gICAgICAgIC8vIHRlbXBvcmFyeSB2YWx1ZXNcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgR2Fpbk1hcERlY29kZXJNYXRlcmlhbCh7XG4gICAgICAgICAgICBnYWluTWFwTWF4OiBbMSwgMSwgMV0sXG4gICAgICAgICAgICBnYWluTWFwTWluOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICBnYW1tYTogWzEsIDEsIDFdLFxuICAgICAgICAgICAgb2Zmc2V0SGRyOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICBvZmZzZXRTZHI6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgIGhkckNhcGFjaXR5TWF4OiAxLFxuICAgICAgICAgICAgaGRyQ2FwYWNpdHlNaW46IDAsXG4gICAgICAgICAgICBtYXhEaXNwbGF5Qm9vc3Q6IDEsXG4gICAgICAgICAgICBnYWluTWFwOiBuZXcgVGV4dHVyZSgpLFxuICAgICAgICAgICAgc2RyOiBuZXcgVGV4dHVyZSgpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFF1YWRSZW5kZXJlcih7XG4gICAgICAgICAgICB3aWR0aDogMTYsXG4gICAgICAgICAgICBoZWlnaHQ6IDE2LFxuICAgICAgICAgICAgdHlwZTogSGFsZkZsb2F0VHlwZSxcbiAgICAgICAgICAgIGNvbG9yU3BhY2U6IExpbmVhclNSR0JDb2xvclNwYWNlLFxuICAgICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgICByZW5kZXJlcjogdGhpcy5fcmVuZGVyZXIsXG4gICAgICAgICAgICByZW5kZXJUYXJnZXRPcHRpb25zOiB0aGlzLl9yZW5kZXJUYXJnZXRPcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHF1YWRSZW5kZXJlclxuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICogQHBhcmFtIHNkckJ1ZmZlclxuICAgKiBAcGFyYW0gZ2Fpbk1hcEJ1ZmZlclxuICAgKi9cbiAgICBhc3luYyByZW5kZXIocXVhZFJlbmRlcmVyLCBtZXRhZGF0YSwgc2RyQnVmZmVyLCBnYWluTWFwQnVmZmVyKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgb3B0aW9uYWwsIHdpbGwgcmVuZGVyIGEgYmxhY2sgZ2Fpbi1tYXAgaWYgbm90IHByZXNlbnRcbiAgICAgICAgY29uc3QgZ2Fpbk1hcEJsb2IgPSBnYWluTWFwQnVmZmVyID8gbmV3IEJsb2IoW2dhaW5NYXBCdWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2RyQmxvYiA9IG5ldyBCbG9iKFtzZHJCdWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgICAgbGV0IHNkckltYWdlO1xuICAgICAgICBsZXQgZ2Fpbk1hcEltYWdlO1xuICAgICAgICBsZXQgbmVlZHNGbGlwID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcEJsb2IgPyBnZXRIVE1MSW1hZ2VGcm9tQmxvYihnYWluTWFwQmxvYikgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBnZXRIVE1MSW1hZ2VGcm9tQmxvYihzZHJCbG9iKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBnYWluTWFwSW1hZ2UgPSByZXNbMF07XG4gICAgICAgICAgICBzZHJJbWFnZSA9IHJlc1sxXTtcbiAgICAgICAgICAgIG5lZWRzRmxpcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcEJsb2IgPyBjcmVhdGVJbWFnZUJpdG1hcChnYWluTWFwQmxvYiwgeyBpbWFnZU9yaWVudGF0aW9uOiAnZmxpcFknIH0pIDogUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoc2RyQmxvYiwgeyBpbWFnZU9yaWVudGF0aW9uOiAnZmxpcFknIH0pXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGdhaW5NYXBJbWFnZSA9IHJlc1swXTtcbiAgICAgICAgICAgIHNkckltYWdlID0gcmVzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdhaW5NYXAgPSBuZXcgVGV4dHVyZShnYWluTWFwSW1hZ2UgfHwgbmV3IEltYWdlRGF0YSgyLCAyKSwgVVZNYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcE1hcExpbmVhckZpbHRlciwgUkdCQUZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSwgMSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBnYWluTWFwLmZsaXBZID0gbmVlZHNGbGlwO1xuICAgICAgICBnYWluTWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2RyID0gbmV3IFRleHR1cmUoc2RySW1hZ2UsIFVWTWFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsIFJHQkFGb3JtYXQsIFVuc2lnbmVkQnl0ZVR5cGUsIDEsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgc2RyLmZsaXBZID0gbmVlZHNGbGlwO1xuICAgICAgICBzZHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBxdWFkUmVuZGVyZXIud2lkdGggPSBzZHJJbWFnZS53aWR0aDtcbiAgICAgICAgcXVhZFJlbmRlcmVyLmhlaWdodCA9IHNkckltYWdlLmhlaWdodDtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhaW5NYXAgPSBnYWluTWFwO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuc2RyID0gc2RyO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2Fpbk1hcE1pbiA9IG1ldGFkYXRhLmdhaW5NYXBNaW47XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYWluTWFwTWF4ID0gbWV0YWRhdGEuZ2Fpbk1hcE1heDtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLm9mZnNldEhkciA9IG1ldGFkYXRhLm9mZnNldEhkcjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLm9mZnNldFNkciA9IG1ldGFkYXRhLm9mZnNldFNkcjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhbW1hID0gbWV0YWRhdGEuZ2FtbWE7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5oZHJDYXBhY2l0eU1pbiA9IG1ldGFkYXRhLmhkckNhcGFjaXR5TWluO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuaGRyQ2FwYWNpdHlNYXggPSBtZXRhZGF0YS5oZHJDYXBhY2l0eU1heDtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLm1heERpc3BsYXlCb29zdCA9IE1hdGgucG93KDIsIG1ldGFkYXRhLmhkckNhcGFjaXR5TWF4KTtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcXVhZFJlbmRlcmVyLnJlbmRlcigpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIFRocmVlLmpzIExvYWRlciBmb3IgdGhlIGdhaW4gbWFwIGZvcm1hdC5cbiAqXG4gKiBAY2F0ZWdvcnkgTG9hZGVyc1xuICogQGdyb3VwIExvYWRlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgR2Fpbk1hcExvYWRlciB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICogaW1wb3J0IHtcbiAqICAgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsXG4gKiAgIExpbmVhckZpbHRlcixcbiAqICAgTWVzaCxcbiAqICAgTWVzaEJhc2ljTWF0ZXJpYWwsXG4gKiAgIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICogICBQbGFuZUdlb21ldHJ5LFxuICogICBTY2VuZSxcbiAqICAgV2ViR0xSZW5kZXJlclxuICogfSBmcm9tICd0aHJlZSdcbiAqXG4gKiBjb25zdCByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKClcbiAqXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgR2Fpbk1hcExvYWRlcihyZW5kZXJlcilcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKFsnc2RyLmpwZWcnLCAnZ2Fpbm1hcC5qcGVnJywgJ21ldGFkYXRhLmpzb24nXSlcbiAqIC8vIGByZXN1bHRgIGNhbiBiZSB1c2VkIHRvIHBvcHVsYXRlIGEgVGV4dHVyZVxuICpcbiAqIGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKClcbiAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAqICAgbmV3IFBsYW5lR2VvbWV0cnkoKSxcbiAqICAgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSlcbiAqIClcbiAqIHNjZW5lLmFkZChtZXNoKVxuICogcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKSlcbiAqXG4gKiAvLyBTdGFydGluZyBmcm9tIHRocmVlLmpzIHIxNTlcbiAqIC8vIGByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVgIGNhblxuICogLy8gYWxzbyBiZSB1c2VkIGFzIEVxdWlyZWN0YW5ndWxhciBzY2VuZSBiYWNrZ3JvdW5kXG4gKiAvL1xuICogLy8gaXQgd2FzIHByZXZpb3VzbHkgbmVlZGVkIHRvIGNvbnZlcnQgaXRcbiAqIC8vIHRvIGEgRGF0YVRleHR1cmUgd2l0aCBgcmVzdWx0LnRvRGF0YVRleHR1cmUoKWBcbiAqIHNjZW5lLmJhY2tncm91bmQgPSByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVcbiAqIHNjZW5lLmJhY2tncm91bmQubWFwcGluZyA9IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nXG4gKlxuICogLy8gcmVzdWx0IG11c3QgYmUgbWFudWFsbHkgZGlzcG9zZWRcbiAqIC8vIHdoZW4geW91IGFyZSBkb25lIHVzaW5nIGl0XG4gKiByZXN1bHQuZGlzcG9zZSgpXG4gKlxuICovXG5jbGFzcyBHYWluTWFwTG9hZGVyIGV4dGVuZHMgTG9hZGVyQmFzZSB7XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBnYWlubWFwIHVzaW5nIHNlcGFyYXRlIGRhdGFcbiAgICAgKiAqIHNkciBpbWFnZVxuICAgICAqICogZ2FpbiBtYXAgaW1hZ2VcbiAgICAgKiAqIG1ldGFkYXRhIGpzb25cbiAgICAgKlxuICAgICAqIHVzZWZ1bCBmb3Igd2VicCBnYWluIG1hcHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmxzIEFuIGFycmF5IGluIHRoZSBmb3JtIG9mIFtzZHIuanBnLCBnYWlubWFwLmpwZywgbWV0YWRhdGEuanNvbl1cbiAgICAgKiBAcGFyYW0gb25Mb2FkIExvYWQgY29tcGxldGUgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIG9uUHJvZ3Jlc3MgUHJvZ3Jlc3MgY2FsbGJhY2ssIHdpbGwgcmVjZWl2ZSBhIHtAbGluayBQcm9ncmVzc0V2ZW50fVxuICAgICAqIEBwYXJhbSBvbkVycm9yIEVycm9yIGNhbGxiYWNrXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBsb2FkKFtzZHJVcmwsIGdhaW5NYXBVcmwsIG1ldGFkYXRhVXJsXSwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IHF1YWRSZW5kZXJlciA9IHRoaXMucHJlcGFyZVF1YWRSZW5kZXJlcigpO1xuICAgICAgICBsZXQgc2RyO1xuICAgICAgICBsZXQgZ2Fpbk1hcDtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICBjb25zdCBsb2FkQ2hlY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2RyICYmIGdhaW5NYXAgJiYgbWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBzb2x2ZXMgIzE2XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXIocXVhZFJlbmRlcmVyLCBtZXRhZGF0YSwgc2RyLCBnYWluTWFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3Ioc2RyVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihnYWluTWFwVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uTG9hZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgb25Mb2FkKHF1YWRSZW5kZXJlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQoc2RyVXJsKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZChnYWluTWFwVXJsKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZChtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBzZHJMZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgbGV0IHNkclRvdGFsID0gMDtcbiAgICAgICAgbGV0IHNkckxvYWRlZCA9IDA7XG4gICAgICAgIGxldCBnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XG4gICAgICAgIGxldCBnYWluTWFwVG90YWwgPSAwO1xuICAgICAgICBsZXQgZ2Fpbk1hcExvYWRlZCA9IDA7XG4gICAgICAgIGxldCBtZXRhZGF0YUxlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgICAgICBsZXQgbWV0YWRhdGFUb3RhbCA9IDA7XG4gICAgICAgIGxldCBtZXRhZGF0YUxvYWRlZCA9IDA7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Qcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gc2RyVG90YWwgKyBnYWluTWFwVG90YWwgKyBtZXRhZGF0YVRvdGFsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRlZCA9IHNkckxvYWRlZCArIGdhaW5NYXBMb2FkZWQgKyBtZXRhZGF0YUxvYWRlZDtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhDb21wdXRhYmxlID0gc2RyTGVuZ3RoQ29tcHV0YWJsZSAmJiBnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSAmJiBtZXRhZGF0YUxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzcyhuZXcgUHJvZ3Jlc3NFdmVudCgncHJvZ3Jlc3MnLCB7IGxlbmd0aENvbXB1dGFibGUsIGxvYWRlZCwgdG90YWwgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHNkclVybCk7XG4gICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQoZ2Fpbk1hcFVybCk7XG4gICAgICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQobWV0YWRhdGFVcmwpO1xuICAgICAgICBjb25zdCBzZHJMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgc2RyTG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKTtcbiAgICAgICAgc2RyTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgc2RyTG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgc2RyTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgICAgIHNkckxvYWRlci5sb2FkKHNkclVybCwgYXN5bmMgKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZHIgYnVmZmVyJyk7XG4gICAgICAgICAgICBzZHIgPSBidWZmZXI7XG4gICAgICAgICAgICBhd2FpdCBsb2FkQ2hlY2soKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIHNkckxlbmd0aENvbXB1dGFibGUgPSBlLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICBzZHJMb2FkZWQgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgIHNkclRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcigpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3Ioc2RyVXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGdhaW5NYXBMb2FkZXIgPSBuZXcgRmlsZUxvYWRlcih0aGlzLl9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLmxvYWQoZ2Fpbk1hcFVybCwgYXN5bmMgKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBnYWlubWFwIGJ1ZmZlcicpO1xuICAgICAgICAgICAgZ2Fpbk1hcCA9IGJ1ZmZlcjtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRDaGVjaygpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgZ2Fpbk1hcExlbmd0aENvbXB1dGFibGUgPSBlLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICBnYWluTWFwTG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICBnYWluTWFwVG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKCk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihnYWluTWFwVXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgIC8vIG1ldGFkYXRhTG9hZGVyLnNldFJlc3BvbnNlVHlwZSgnanNvbicpXG4gICAgICAgIG1ldGFkYXRhTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgbWV0YWRhdGFMb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICBtZXRhZGF0YUxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICBtZXRhZGF0YUxvYWRlci5sb2FkKG1ldGFkYXRhVXJsLCBhc3luYyAoanNvbikgPT4ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmXG4gICAgICAgICAgICAgdGhpcyBjb25kaXRpb24gZXhpc3RzIG9ubHkgYmVjYXVzZSBvZiB0aHJlZS5qcyB0eXBlcyArIHN0cmljdCBtb2RlXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0YWRhdGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgY2hlY2sgb24gSlNPTiBmaWxlIGFuZCByZW1vdmUgdGhpcyBlc2xpbnQgZGlzYWJsZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgbWV0YWRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgICAgICAgYXdhaXQgbG9hZENoZWNrKCk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBtZXRhZGF0YUxlbmd0aENvbXB1dGFibGUgPSBlLmxlbmd0aENvbXB1dGFibGU7XG4gICAgICAgICAgICBtZXRhZGF0YUxvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgbWV0YWRhdGFUb3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXIoKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgVGhyZWUuanMgTG9hZGVyIGZvciBhIEpQRUcgd2l0aCBlbWJlZGRlZCBnYWlubWFwIG1ldGFkYXRhLlxuICpcbiAqIEBjYXRlZ29yeSBMb2FkZXJzXG4gKiBAZ3JvdXAgTG9hZGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBIRFJKUEdMb2FkZXIgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcydcbiAqIGltcG9ydCB7XG4gKiAgIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLFxuICogICBMaW5lYXJGaWx0ZXIsXG4gKiAgIE1lc2gsXG4gKiAgIE1lc2hCYXNpY01hdGVyaWFsLFxuICogICBQZXJzcGVjdGl2ZUNhbWVyYSxcbiAqICAgUGxhbmVHZW9tZXRyeSxcbiAqICAgU2NlbmUsXG4gKiAgIFdlYkdMUmVuZGVyZXJcbiAqIH0gZnJvbSAndGhyZWUnXG4gKlxuICogY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpXG4gKlxuICogY29uc3QgbG9hZGVyID0gbmV3IEhEUkpQR0xvYWRlcihyZW5kZXJlcilcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZWcnKVxuICogLy8gYHJlc3VsdGAgY2FuIGJlIHVzZWQgdG8gcG9wdWxhdGUgYSBUZXh0dXJlXG4gKlxuICogY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKVxuICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKFxuICogICBuZXcgUGxhbmVHZW9tZXRyeSgpLFxuICogICBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZSB9KVxuICogKVxuICogc2NlbmUuYWRkKG1lc2gpXG4gKiByZW5kZXJlci5yZW5kZXIoc2NlbmUsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpKVxuICpcbiAqIC8vIFN0YXJ0aW5nIGZyb20gdGhyZWUuanMgcjE1OVxuICogLy8gYHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZWAgY2FuXG4gKiAvLyBhbHNvIGJlIHVzZWQgYXMgRXF1aXJlY3Rhbmd1bGFyIHNjZW5lIGJhY2tncm91bmRcbiAqIC8vXG4gKiAvLyBpdCB3YXMgcHJldmlvdXNseSBuZWVkZWQgdG8gY29udmVydCBpdFxuICogLy8gdG8gYSBEYXRhVGV4dHVyZSB3aXRoIGByZXN1bHQudG9EYXRhVGV4dHVyZSgpYFxuICogc2NlbmUuYmFja2dyb3VuZCA9IHJlc3VsdC5yZW5kZXJUYXJnZXQudGV4dHVyZVxuICogc2NlbmUuYmFja2dyb3VuZC5tYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmdcbiAqXG4gKiAvLyByZXN1bHQgbXVzdCBiZSBtYW51YWxseSBkaXNwb3NlZFxuICogLy8gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgaXRcbiAqIHJlc3VsdC5kaXNwb3NlKClcbiAqXG4gKi9cbmNsYXNzIEhEUkpQR0xvYWRlciBleHRlbmRzIExvYWRlckJhc2Uge1xuICAgIC8qKlxuICAgICAqIExvYWRzIGEgSlBFRyBjb250YWluaW5nIGdhaW4gbWFwIG1ldGFkYXRhXG4gICAgICogUmVuZGVycyBhIG5vcm1hbCBTRFIgaW1hZ2UgaWYgZ2Fpbm1hcCBkYXRhIGlzIG5vdCBmb3VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCBBbiBhcnJheSBpbiB0aGUgZm9ybSBvZiBbc2RyLmpwZywgZ2Fpbm1hcC5qcGcsIG1ldGFkYXRhLmpzb25dXG4gICAgICogQHBhcmFtIG9uTG9hZCBMb2FkIGNvbXBsZXRlIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBvblByb2dyZXNzIFByb2dyZXNzIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgYSB7QGxpbmsgUHJvZ3Jlc3NFdmVudH1cbiAgICAgKiBAcGFyYW0gb25FcnJvciBFcnJvciBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgICBjb25zdCBxdWFkUmVuZGVyZXIgPSB0aGlzLnByZXBhcmVRdWFkUmVuZGVyZXIoKTtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG4gICAgICAgIGxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgIGxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgICAgIGxvYWRlci5sb2FkKHVybCwgYXN5bmMgKGpwZWcpID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YganBlZyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ1ZmZlciwgcmVjZWl2ZWQgW3N0cmluZ10sIHdhcyBleHBlY3RpbmcgW0FycmF5QnVmZmVyXScpO1xuICAgICAgICAgICAgY29uc3QganBlZ0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGpwZWcpO1xuICAgICAgICAgICAgbGV0IHNkckpQRUc7XG4gICAgICAgICAgICBsZXQgZ2Fpbk1hcEpQRUc7XG4gICAgICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhY3Rpb25SZXN1bHQgPSBhd2FpdCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHKGpwZWdCdWZmZXIpO1xuICAgICAgICAgICAgICAgIC8vIGdhaW4gbWFwIGlzIHN1Y2Nlc3NmdWxseSByZWNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgICAgc2RySlBFRyA9IGV4dHJhY3Rpb25SZXN1bHQuc2RyO1xuICAgICAgICAgICAgICAgIGdhaW5NYXBKUEVHID0gZXh0cmFjdGlvblJlc3VsdC5nYWluTWFwO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gZXh0cmFjdGlvblJlc3VsdC5tZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyIHRoZSBTRFIgdmVyc2lvbiBpZiB0aGlzIGlzIG5vdCBhIGdhaW5tYXBcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciB8fCBlIGluc3RhbmNlb2YgR2Fpbk1hcE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWlsdXJlIHRvIHJlY29uc3RydWN0IGFuIEhEUiBpbWFnZSBmcm9tICR7dXJsfTogR2FpbiBtYXAgbWV0YWRhdGEgbm90IGZvdW5kIGluIHRoZSBmaWxlLCBIRFJKUEdMb2FkZXIgd2lsbCByZW5kZXIgdGhlIFNEUiBqcGVnYCk7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2Fpbk1hcE1pbjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2Fpbk1hcE1heDogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FtbWE6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWluOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNYXg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRIZHI6IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFNkcjogWzAsIDAsIDBdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNkckpQRUcgPSBqcGVnQnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzb2x2ZXMgIzE2XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyKHF1YWRSZW5kZXJlciwgbWV0YWRhdGEsIHNkckpQRUcsIGdhaW5NYXBKUEVHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIG9uTG9hZChxdWFkUmVuZGVyZXIpO1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICAgICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICB9LCBvblByb2dyZXNzLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG4gICAgfVxufVxuXG5leHBvcnQgeyBHYWluTWFwRGVjb2Rlck1hdGVyaWFsLCBHYWluTWFwTG9hZGVyLCBIRFJKUEdMb2FkZXIsIEhEUkpQR0xvYWRlciBhcyBKUEVHUkxvYWRlciwgTVBGRXh0cmFjdG9yLCBRdWFkUmVuZGVyZXIsIGRlY29kZSwgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRywgZXh0cmFjdFhNUCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\n");

/***/ })

};
;